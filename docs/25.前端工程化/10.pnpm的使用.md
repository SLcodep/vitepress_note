---
title: pnpm的使用
date: 2025-11-27 17:24:35
permalink: /enginee/pnpm
# titleTag: 可选，给标题添加特殊标签
categories:
  - 前端工程化
tags:
  - 前端工程化
lastUpdated: true
---

## pnpm 的安装

首先要准备 node 环境，之后通过 npm 全局安装

```
npm install pnpm -g
```

- **更换 pnpm 的镜像源**

```yaml
pnpm config get registry        //查看当前使用的镜像源
https://registry.npmjs.org/     //默认镜像源

pnpm config set registry https://registry.npmmirror.com/   //淘宝npm镜像源
pnpm config set registry https://registry.npmjs.org        //还原为默认npm源
```

## 使用pnpm创建项目

```yaml
# 1. 初始化项目（生成 package.json）
pnpm init -y  # -y 跳过交互，直接生成默认 package.json

# 2. 安装依赖（这一步才会生成 node_modules + pnpm-lock.yaml）
# 示例1：安装生产依赖（如 axios）
pnpm add axios

# 示例2：安装开发依赖（如 eslint）
pnpm add -D eslint

# 示例3：安装 package.json 中已声明的所有依赖
pnpm install  # 简写：pnpm i

```

## pnpm与npm、yarn的区别？

> npm、yarn、pnpm 的核心区别在于依赖管理策略和性能优化:
> npm和yarn都是采用扁平化依赖树，可能存在依赖重复;pnpm：采用 “依赖目录 + 软链接”，实现依赖共享，无重复。


- **npm@2**
npm@3之前，npm的问题是依赖嵌套深，一个包会有多个副本存在。出现的问题主要是：在 npm2 时代，依赖树是严格按照包的层级结构进行安装的，不同包的相同依赖可能会被多次安装，导致大量冗余。例如，项目中有 A、B 两个包，它们都依赖 C 包的 1.0 版本，在 npm2 中，C 包会在 A 和 B 的依赖目录下分别安装一次。

- **npm@3**
npm@3采用扁平依赖关系树来解决上述问题，但是存在新的问题：
1.模块可以访问并非其依赖的包
2.依赖树的扁平化算法相当复杂
3.所有包的文件夹都得复制到项目的node_modules目录下，如packageA必须放到packageB的node_modules下才能正常工作，而如果强行拉平(扁平)所有内容,会导致错误。
还有**幻影依赖**的问题,即项目中实际使用的某个依赖，在package.json中并未声明，这可能导致依赖版本不兼容等隐患。
```js
// package.json
{
  "dependencies": {
    "A": "^1.0.0" // A 依赖于 B@^2.0.0
  }
}
//比如现在A依赖于B，但是在package.json内未进行声明B，而在node_modules依赖树扁平化因为A依赖B，B可能会被提升到顶层node_modules。会导致即使未声明，而B的依赖版本可能会与A进行绑定，导致A更新，B版本发生变化。导致依赖B的旧版本API在B进行更新后无法使用。
node_modules/
├── A/
└── B/  // 被提升到顶层
// 未在 package.json 中声明 B，但仍可引入
const B = require('B');
```
比如现在A依赖于B，但是在package.json内未进行声明B，而在node_modules依赖树扁平化因为A依赖B，B可能会被提升到顶层node_modules。会导致即使未声明，而B的依赖版本可能会与A进行绑定，导致A更新，B版本发生变化。导致依赖B的旧版本API在B进行更新后无法使用。

- **pnpm**

pnpm通过将所有依赖包存储在一个全局的内容可寻址存储（content-addressable store）中，然后通过硬链接（hard links）将项目所需的依赖链接到项目的node_modules目录。这意味着，无论项目中有多少个地方依赖同一个包，磁盘上实际只存储一份该包的文件。例如下图，foo下需要bar的依赖包，就通过`../../bar/2.0.0/node_modules/bar`来实现引入存储的bar的依赖。
此外，pnpm 在安装依赖时，会严格按照package.json中的声明进行安装，避免了幻影依赖的问题，使依赖管理更加可靠。
![pnpm](/public/qian/pnpm.png)

## 怎么理解pnpm中的硬链接与软链接?
:::tip
硬链接和软链接是文件系统的两种引用方式：
1.硬链接：是文件的另一个入口，与原文件共享同一个 inode（文件唯一标识），删除原文件不影响硬链接；
2.软链接：是指向原文件的路径指针，有独立的 inode，原文件删除后软链接失效；
3.pnpm 用硬链接实现全局依赖的磁盘复用，用软链接维持项目 node_modules 的结构，从而大幅节省磁盘空间、提升安装速度。
:::
在上面的那个图中`foo -> .registry.npmjs.org/foo/1.0.0/node_modules/foo`和`bar -> ../../bar/2.0.0/node_modules/bar`都是软链接。

pnpm的核心是**内容寻址存储**,所有包会被统一存到电脑的`node_modules/.pnpm`目录下,再通过链接的方式 “复用” 包，而非重复复制。
- **1. 硬链接：节省磁盘空间**
**作用:** 把`.pnpm`目录中存储的包，硬链接到项目的`node_modules`里。
硬链接的特点是：多个文件指向同一块磁盘数据，修改其中一个，其他也会变；删除其中一个，数据不会被删除（直到所有硬链接都被删）。
**举例：** 项目 A 和项目 B 都依赖`lodash@4.17.0`，pnpm 只会在`.pnpm`里存一份lodash，然后给两个项目的`node_modules`分别创建硬链接指向它，避免重复占用磁盘。

- **2.软链接（符号链接）：避免幻影依赖**
**作用**：在项目的node_modules中，通过软链接严格隔离依赖范围。
软链接的特点是：类似 “快捷方式”，只记录目标文件的路径；目标文件删除后，软链接会失效。
**举例**:项目依赖A，而A依赖B。pnpm 会在`node_modules/A/node_modules`下创建软链接指向`.pnpm`里的B，这样项目代码无法直接访问B（因为B不在项目顶层node_modules），只能通过A间接访问，从根源上杜绝了幻影依赖。

- 总结
所有包的 “存储” 用硬链接（节省空间）
所有包的 “依赖关系连接” 用软链接（隔离范围）

```JSON
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  }
}
```
```JS
node_modules/
├── react -> ./.pnpm/react@18.2.0/node_modules/react   （软链接）
├── react-dom -> ./.pnpm/react-dom@18.2.0/node_modules/react-dom   （软链接）
└── .pnpm/
    ├── react@18.2.0/
    │   └── node_modules/
    │       └── react/
    │           ├── index.js   （硬链接 -> ~/.pnpm-store/...）
    │           └── ...
    ├── react-dom@18.2.0/
    │   └── node_modules/
    │       └── react-dom/
    │           ├── index.js   （硬链接 -> ~/.pnpm-store/...）
    │           └── ...
    └── ...
```
