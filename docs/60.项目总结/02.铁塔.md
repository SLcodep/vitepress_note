---
title: 中国铁塔证件识别项目
date: 2025-01-05 00:58:41
permalink: /qianduan/铁塔证件识别项目
categories:
  - 前端
tags:
  - 项目
---

::: info 项目介绍
**项目概述：** 团队受中国铁塔公司委托，搭建一套用于工作人员在线提交图片或者房产证件信息，对于上传的图片进行 p 图检测，对于上传的房产证件进行房产证信息识别与提取和相同房产证相似度匹配并且能够导出报告的在线检测系统。
**项目技术**：采用 Vue3.0+ElementPlus+Axios+Pinia+Xlsx 实现
亮点：1）实现用户管理与权限控制 2）实现前端文件夹上传功能解决文件批量上传痛点；3）利用 keep-alive 保存组件状态减少重复请求；4）应用路由懒加载优化性能；5）通过 XLSX 库实现表格导出功能
:::

## 1.前端权限控制方案
主要包括的内容是：路由控制、组件控制、权限管理、后端验证、缓存同步等多个环节。
前端权限控制的核心准则：
1.前端只控制界面展示，不能控制数据和行为
2.权限要后端返回、前端解析
3.所有权限判断必须同步做后端验证
所以前端权限控制主要是权限路由守卫、控制按钮和组件显示，目的是减少页面结构暴露、增强用户体验的功效。

**1.权限路由守卫**
通过 Vue Router 的导航守卫beforeEach() 来进行权限校验，拦截不符合权限的访问请求。

## 2.利用keep-alive保存组件状态减少重复请求

>在这个项目中，经常做的事是上传图片到服务器，通过算法将结果再返回给前端页面。之后如果切换到其他页面，返回时之前上传的图片和返回的检测结果都被刷新。用户体验极差，服务器也因为重复请求列表数据而压力倍增。

**生命周期的改变（关键点）**

**1.没有 keep-alive 时：**
- 进入：`created` -> `mounted`
- 离开：`destroyed`
- 再次进入：`created` -> `mounted` （API 请求通常放在这里，所以会重复跑）

**2.有 keep-alive 时：**
- 初次进入：`created` -> `mounted `-> `activated`
- 离开：`deactivated` （注意：没有 destroyed）
- 再次进入：`activated` （注意：没有 created 和 mounted）

```js
<template>
    <!-- 将（只）缓存组件name为a或者b的组件, 结合动态组件使用 -->
    <keep-alive include="a,b">
          <component :is="view"></component>
    </keep-alive>

    <!-- 组件name为c的组件不缓存(可以保留它的状态或避免重新渲染) -->
    <keep-alive exclude="c"> 
          <component :is="view"></component>
    </keep-alive>
    
    <!-- 使用正则表达式，需使用v-bind -->
    <keep-alive :include="/a|b/">
          <component :is="view"></component>
    </keep-alive>

    <!-- 动态判断 -->
    <keep-alive :include="includedComponents">
        <router-view></router-view>
    </keep-alive>
    
    <!-- 如果同时使用include,exclude,那么exclude优先于include， 下面的例子只缓存a组件 -->
    <keep-alive include="a,b" exclude="b"> 
          <component :is="view"></component>
    </keep-alive>

    <!-- 如果缓存的组件超过了max设定的值5，那么将删除第一个被缓存的组件 -->
    <keep-alive exclude="c" max="5"> 
      <component></component>
    </keep-alive>
</template>
```

## 3.路由懒加载优化
>懒加载解决了首屏慢的问题，但也带来了后续跳转慢的风险。所以我结合了 Prefetch（预获取）策略。对于核心路径（Critical Path）上的页面，我配置了 `webpackPrefetch: true`，让浏览器在网络空闲时默默下载。这样既保证了首屏速度，又实现了后续操作的‘秒开’。

首先明确路由懒加载的目的是显著提升首屏加载速度(FCP)。要思考几个问题,一个是这个路由拆分要如何划分？第二个问题就是在首屏加载完成后，为了之后跳转加载速度快，启动预获取。
```js
//预获取
component: () => import(
  /* webpackChunkName: "user", webpackPrefetch: true */ 
  '@/views/user/index.vue'
)
```

## 4.用户体验优化
针对**上传慢 + 算法慢**导致体验割裂的问题，对前端进行一定的优化。
1.图片质量压缩。OCR检测算法一般不太需要分辨率过高的图片，
2.分片上传 + 进度可视化。通过显示上传进度能是用户对时间判断更清晰。
3.多阶段反馈。
```text
✔ 图片上传完成
✔ 正在校验证件完整性
✔ 正在检测异常篡改区域
⏳ 正在生成检测结果
```
4.本地缓存+Hash去重。用户在检测时大量上传图片，在这其中容易有重复的图片。
```text
选图
 ↓
前端算 hash
 ↓
查本地缓存
 ↓
有结果 → 直接展示
 ↓
没结果 → 上传 → 存缓存
```
### 4.1 图片质量压缩
### 4.2 分片上传 + 进度可视化
### 4.3 多阶段反馈
### 4.4 本地缓存+Hash去重
