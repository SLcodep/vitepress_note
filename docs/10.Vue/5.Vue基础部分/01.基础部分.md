---
title: 基础部分
date: 2025-11-27 17:24:35
permalink: /vue/基础部分
# titleTag: 
categories:
  - Vue
tags:
  - vue
---

> 本文档作为基础知识，更多关注的是什么？区别是什么？不需要深度的知道为什么这么做，在原理篇部分才会深度讲解为什么这么做、怎么做的？

# 1.组件的基础
> 一个再复杂的组件，都是由三部分组成的：prop、event、slot，它们构成了 Vue.js 组件的 API。不同组件会负责不同的内容，但一定要清楚数据放在哪里？是通过封装好的请求从服务端拿到数据进行渲染，还是通过插槽的方式进行父子组件数据的传递?

## 1.1 prop和event
### 子组件接收
**子组件是如何通过props接收数据的？**

首先是父组件传递数据
```vue {v-pre}
<script setup>
import Child from './Child.vue'
const parentCount = ref(5)
const parentMsg = '父组件传递的文本'
</script>

<template>
  <Child :msg="parentMsg" :count="parentCount" />
</template>
```
子组件利用defineProps创建props来接收
> 不能解构 `props`（解构会丢失响应式），如需解构需用 `toRefs`
>
> ```html {v-pre}
> const { count } = toRefs(props); 
> ```

```html {v-pre}
<script setup>
// 方式1：简洁声明（仅指定类型）
const props = defineProps(['msg', 'count'])
// 显式声明接收的 Prop
const props = defineProps({
  msg: String,
  count: [Number, String]
});

console.log(props.msg); 
console.log(props.count); 
</script>
```

### 子组件如何修改数据？
因为在vue中采用的是单向数据流，所以子组件要想修改数据，就要通知父组件进行修改。在vue3中是通过defindemit创建emit来将监听方法返回给父组件。

## 1.2 插槽slot
### 子组件和slot的区别是什么？
> 首先，要弄清楚一个问题，既然子组件能接收父组件的内容，**为什么还需要slot?**
>
> **子组件的内容是 “写死的”**，父组件只能通过 prop 传递数据，无法修改子组件的 HTML 结构 / 内容，灵活性极低。所以**子组件如何接收模板内容呢**？
>
> **slot** 理解为：**子组件给父组件留的 “自定义窗口”**，窗口位置由子组件定，窗口里放什么由父组件定。

### 不同的slot
> 为什么要有不同的插槽？
>
> 插槽slot分为默认插槽、具名插槽、作用域插槽
>
> 具名插槽是为了父组件能定制子组件多个区域，通过name区分不同插槽；
>
> 作用域插槽的一个作用是，父组件能通过作用域插槽来接收子组件的数据，来判断是否进行渲染，如果value> 0 ? '有货' : '无货'

#### 默认插槽
```vue {v-pre}
//子组件FancyButton.vue，插槽出口<slot>
<button class="fancy-btn">
  <slot>
   	默认是me   //如果父组件中没有设置插槽内容，会渲染默认内容 
   </slot> <!-- 插槽出口 -->
</button>

//父组件提供插槽内容(模板内容)
<FancyButton>
  Click me! <!-- 插槽内容 -->
</FancyButton>
```

#### 默认插槽
> 具名插槽是为了父组件能定制子组件多个区域，通过name区分不同插槽；如标题、主要内容、底部
> 子组件提供带有不同name，给slot分配唯一的ID。没有体统就是name="default"
> 缩写是#，如name="age"

```html {v-pre}
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

父组件
```html {v-pre}
<BaseLayout>
  <template #header>
    <h1>Here might be a page title</h1>
  </template>

  <template #default>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </template>

  <template #footer>
    <p>Here's some contact info</p>
  </template>
</BaseLayout>
```
#### 作用域插槽
> 比如通过子组件传来的数据，判断渲染内容，或者根据子组件传来的数据进行渲染

```html {v-pre}
<!-- <MyComponent> 的模板 -->
<div>
  <slot :text="greetingMessage" :count="1"></slot>
</div>
```
父组件通过使用v-slot接收

```html {v-pre}
<MyComponent v-slot="slotProps">
  {{ slotProps.text }} {{ slotProps.count }}
</MyComponent>
```
> 注意，具名插槽的作用域插槽不一样，要使用显示的`<template>`标签

子组件：
```html {v-pre}
<div>
  <slot :message="hello"></slot>
  <slot name="footer" />
</div>
```
父组件：
```html {v-pre}
<MyComponent>
  <!-- 使用显式的默认插槽 -->
  <template #default="{ message }">
    <p>{{ message }}</p>
  </template>

  <template #footer>
    <p>Here's some contact info</p>
  </template>
</MyComponent>
```




