---
title: 面试题合集
date: 2025-11-27 17:24:35
permalink: /vue/04
# titleTag: 
categories:
  - Vue
tags:
  - vue
---
<CollapsibleToc 
  title="快速导航" 
  :defaultOpen="true" 
  :minLevel="2" 
  :maxLevel="3" 
/>

## 1.Vue2和Vue3的区别？

- **响应式机制不同**

**Vue2**：基于**Object.defineProperty**实现，需要提前遍历对象属性，存在天然局限：

- 无法监听对象新增 / 删除的属性（需用`this.$set`手动处理）
- 无法监听数组通过索引修改的元素（如`arr[0] = 1`）
- 初始化时要递归遍历所有属性，大对象性能损耗明显


- **Vue3**：改用 **Proxy**代理整个对象，解决了上述问题：
  - 自动监听对象新增 / 删除属性
  - 原生支持数组索引修改和`length`变化
  - 懒代理机制，只有访问属性时才会递归，性能更优

- **代码组织方式差异**

**Vue2**：主要用**选项式 API（Options API）**，代码按`data`、`methods`、`computed`等选项划分，逻辑分散。

```javascript
export default {
  data() { return { count: 0 } },
  methods: { increment() { this.count++ } },
  computed: { double() { return this.count * 2 } }
}
```

**Vue3**：新增**组合式 API（Composition API）**，可按业务逻辑聚合代码，适合复杂组件

```javascript
import { ref, computed } from 'vue'
export default {
  setup() {
    const count = ref(0)
    const increment = () => count.value++
    const double = computed(() => count.value * 2)
    return { count, increment, double }
  }
}
```

- **生命周期变化**

- Vue 2 提供了一系列的生命周期钩子，如 `created`，`mounted`，`updated`，`destroyed` 等。
- Vue 3 对这些生命周期钩子进行了重命名和调整，以更好地与 Composition API 配合。例如，`beforeDestroy` 和 `destroyed` 分别更名为 `beforeUnmount` 和 `unmounted`。此外，Vue 3 引入了新的生命周期钩子，如 `onMounted`，`onUpdated`，`onUnmounted` 等，用于组合式 API。



## 2.MVVM 的理解

`MVVM` 是一种软件架构模式，MVVM 分为 `Model`、`View`、`ViewModel`

- `Model`代表数据模型，数据和业务逻辑都在 Model 层中定义；
- `View`代表 UI 视图，负责数据的展示；
- `ViewModel`负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；

![76423568417](../../public/vue/1764235684171.png)




## 3.v-if与v-show的区别？
## 4.v-if和v-for为什么不能放到一起？
## 5.Vue组件通信方式
## 6.v-model 是如何实现的，语法糖实际是什么？
## 7.data为什么是一个函数而不是对象
**核心原因**:避免多个组件实例共享同一份数据，导致数据污染
  - 若`data`是对象：所有组件实例会共享同一个对象的引用 → 改一个实例的 data，其他实例的 data 会同步变化（数据污染）；
  - 若`data`是函数：每次创建组件实例时，Vue 会执行该函数，返回一个「新的、独立的对象」→ 每个实例拥有专属的 data，互不干扰。

**底层逻辑**:对象是"引用类型",变量存储的是对象的内存地址，而非值本身

## 8.Vue中key的作用是什么？
Vue中key的核心作用是作为虚拟 DOM 节点的唯一标识，帮助Vue的diff算法精准识别 DOM 节点的身份，从而优化渲染逻辑、避免渲染异常。
- 无key时，Vue 按「节点位置」就地更新，易导致 DOM 与数据不匹配
- 有 key 时，Vue 按 key 匹配新旧节点，仅复用 key 相同的节点，彻底避免因 “位置复用” 导致的渲染异常。

**为什么不建议用 index 作为 key?**
如果将数组下标作为 key 值，那么当列表发生变化时，可能会导致 key 值发生改变，从而引发不必要的组件重新渲染，甚至会导致性能问题。例如，当删除列表中某个元素时，其后面的所有元素的下标都会发生改变，导致 Vue 重新渲染整个列表。

## 9.watch 和 computed 有什么区别?
- 计算属性来描述依赖响应式状态的复杂逻辑
- watch用于每次响应式属性发生变化时的监听












