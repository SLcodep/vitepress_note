---
title: 面试题合集
date: 2025-11-27 17:24:35
permalink: /vue/04
# titleTag: 
categories:
  - Vue
tags:
  - vue
---
<CollapsibleToc 
  title="快速导航" 
  :defaultOpen="true" 
  :minLevel="2" 
  :maxLevel="3" 
/>

## 1.Vue2和Vue3的区别？

- **响应式机制不同**

**Vue2**：基于**Object.defineProperty**实现，需要提前遍历对象属性，存在天然局限：

- 无法监听对象新增 / 删除的属性（需用`this.$set`手动处理）
- 无法监听数组通过索引修改的元素（如`arr[0] = 1`）
- 初始化时要递归遍历所有属性，大对象性能损耗明显


- **Vue3**：改用 **Proxy**代理整个对象，解决了上述问题：
  - 自动监听对象新增 / 删除属性
  - 原生支持数组索引修改和`length`变化
  - 懒代理机制，只有访问属性时才会递归，性能更优

- **代码组织方式差异**

**Vue2**：主要用**选项式 API（Options API）**，代码按`data`、`methods`、`computed`等选项划分，逻辑分散。

```javascript
export default {
  data() { return { count: 0 } },
  methods: { increment() { this.count++ } },
  computed: { double() { return this.count * 2 } }
}
```

**Vue3**：新增**组合式 API（Composition API）**，可按业务逻辑聚合代码，适合复杂组件

```javascript
import { ref, computed } from 'vue'
export default {
  setup() {
    const count = ref(0)
    const increment = () => count.value++
    const double = computed(() => count.value * 2)
    return { count, increment, double }
  }
}
```

- **生命周期变化**

- Vue 2 提供了一系列的生命周期钩子，如 `created`，`mounted`，`updated`，`destroyed` 等。
- Vue 3 对这些生命周期钩子进行了重命名和调整，以更好地与 Composition API 配合。例如，`beforeDestroy` 和 `destroyed` 分别更名为 `beforeUnmount` 和 `unmounted`。此外，Vue 3 引入了新的生命周期钩子，如 `onMounted`，`onUpdated`，`onUnmounted` 等，用于组合式 API。



## 2.MVVM 的理解

`MVVM` 是一种软件架构模式，MVVM 分为 `Model`、`View`、`ViewModel`

- `Model`代表数据模型，数据和业务逻辑都在 Model 层中定义；
- `View`代表 UI 视图，负责数据的展示；
- `ViewModel`负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；

![76423568417](../../public/vue/1764235684171.png)




## 3.v-if与v-show的区别？
- **控制手段**
  - `v-show`隐藏则是为该元素添加`css--display:none`，dom元素依旧还在
  - `v-if`显示隐藏是将dom元素整个添加或删除
- **编译条件**
  - v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染
  - v-show 由false变为true的时候不会触发组件的生命周期
  - v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法

#### 使用场景
- ​**​何时使用 v-if？​**
  - **条件在运行时很少改变**,或者根本不会改变的场景。例如，根据用户权限决定是否渲染某个管理功能模块。
  - **需要惰性加载​**​以提升初始加载性能时。例如，一个沉重的、包含复杂逻辑或大量 DOM 的子组件，如果一开始不需要显示，使用 v-if可以避免不必要的渲染开销。
- ​**​何时使用 v-show？​**
  - **条件需要非常频繁地切换**​​。典型的例子是标签页（Tab）切换或可折叠菜单的显示/隐藏。在这种场景下，v-show仅切换 CSS 的性能远优于 v-if反复创建和销毁组件的开销。



## 4.v-if和v-for为什么不能放到一起？
## 5.Vue组件通信方式
## 6.v-model 是如何实现的，语法糖实际是什么？
## 7.data为什么是一个函数而不是对象
**核心原因**:避免多个组件实例共享同一份数据，导致数据污染
  - 若`data`是对象：所有组件实例会共享同一个对象的引用 → 改一个实例的 data，其他实例的 data 会同步变化（数据污染）；
  - 若`data`是函数：每次创建组件实例时，Vue 会执行该函数，返回一个「新的、独立的对象」→ 每个实例拥有专属的 data，互不干扰。

**底层逻辑**:对象是"引用类型",变量存储的是对象的内存地址，而非值本身

## 8.Vue中key的作用是什么？
Vue中key的核心作用是作为虚拟 DOM 节点的唯一标识，帮助Vue的diff算法精准识别 DOM 节点的身份，从而优化渲染逻辑、避免渲染异常。
- 无key时，Vue 按「节点位置」就地更新，易导致 DOM 与数据不匹配
- 有 key 时，Vue 按 key 匹配新旧节点，仅复用 key 相同的节点，彻底避免因 “位置复用” 导致的渲染异常。

**为什么不建议用 index 作为 key?**
如果将数组下标作为 key 值，那么当列表发生变化时，可能会导致 key 值发生改变，从而引发不必要的组件重新渲染，甚至会导致性能问题。例如，当删除列表中某个元素时，其后面的所有元素的下标都会发生改变，导致 Vue 重新渲染整个列表。

## 9.watch 和 computed 有什么区别?
- 计算属性来描述依赖响应式状态的复杂逻辑
- watch用于每次响应式属性发生变化时的监听












