---
title: 面试题合集
date: 2025-11-27 17:24:35
permalink: /vue/04
# titleTag: 
categories:
  - Vue
tags:
  - vue
---
<CollapsibleToc 
  title="快速导航" 
  :defaultOpen="true" 
  :minLevel="2" 
  :maxLevel="3" 
/>

## 1.Vue2和Vue3的区别？

- **响应式机制不同**

**Vue2**：基于**Object.defineProperty**实现，需要提前遍历对象属性，存在天然局限：

- 无法监听对象新增 / 删除的属性（需用`this.$set`手动处理）
- 无法监听数组通过索引修改的元素（如`arr[0] = 1`）
- 初始化时要递归遍历所有属性，大对象性能损耗明显


- **Vue3**：改用 **Proxy**代理整个对象，解决了上述问题：
  - 自动监听对象新增 / 删除属性
  - 原生支持数组索引修改和`length`变化
  - 懒代理机制，只有访问属性时才会递归，性能更优

- **代码组织方式差异**

**Vue2**：主要用**选项式 API（Options API）**，代码按`data`、`methods`、`computed`等选项划分，逻辑分散。

```javascript
export default {
  data() { return { count: 0 } },
  methods: { increment() { this.count++ } },
  computed: { double() { return this.count * 2 } }
}
```

**Vue3**：新增**组合式 API（Composition API）**，可按业务逻辑聚合代码，适合复杂组件

```javascript
import { ref, computed } from 'vue'
export default {
  setup() {
    const count = ref(0)
    const increment = () => count.value++
    const double = computed(() => count.value * 2)
    return { count, increment, double }
  }
}
```

- **生命周期变化**

- Vue 2 提供了一系列的生命周期钩子，如 `created`，`mounted`，`updated`，`destroyed` 等。
- Vue 3 对这些生命周期钩子进行了重命名和调整，以更好地与 Composition API 配合。例如，`beforeDestroy` 和 `destroyed` 分别更名为 `beforeUnmount` 和 `unmounted`。此外，Vue 3 引入了新的生命周期钩子，如 `onMounted`，`onUpdated`，`onUnmounted` 等，用于组合式 API。



## 2.MVVM 的理解

`MVVM` 是一种软件架构模式，MVVM 分为 `Model`、`View`、`ViewModel`

- `Model`代表数据模型，数据和业务逻辑都在 Model 层中定义；
- `View`代表 UI 视图，负责数据的展示；
- `ViewModel`负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；

![76423568417](../../public/vue/1764235684171.png)




## 3.v-if与v-show的区别？
- **控制手段**
  - `v-show`隐藏则是为该元素添加`css--display:none`，dom元素依旧还在
  - `v-if`显示隐藏是将dom元素整个添加或删除
- **编译条件**
  - v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染
  - v-show 由false变为true的时候不会触发组件的生命周期
  - v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法

#### 使用场景
- ​**​何时使用 v-if？​**
  - **条件在运行时很少改变**,或者根本不会改变的场景。例如，根据用户权限决定是否渲染某个管理功能模块。
  - **需要惰性加载​**​以提升初始加载性能时。例如，一个沉重的、包含复杂逻辑或大量 DOM 的子组件，如果一开始不需要显示，使用 v-if可以避免不必要的渲染开销。
- ​**​何时使用 v-show？​**
  - **条件需要非常频繁地切换**​​。典型的例子是标签页（Tab）切换或可折叠菜单的显示/隐藏。在这种场景下，v-show仅切换 CSS 的性能远优于 v-if反复创建和销毁组件的开销。



## 4.v-if和v-for为什么不能放到一起？
## 5.Vue组件通信方式
## 6.v-model 是如何实现的，语法糖实际是什么？
> **口语化回答**
> v-model是Vue 中数据双向绑定的指令，可以绑定一个响应式数据到视图，同时视图的变化能改变该值。
> - 当作用在**表单**上：通过 v-bind:value 绑定数据，v-on:input 来监听数据变化并修改 value
> - 当作用在**组件**上：本质上是一个父子通信语法糖，通过 props 和 $emit 实现。


**(1)作用在表单元素上**
动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值
```js
<input v-model="sth" />
//  等同于
<input 
    v-bind:value="message" 
    v-on:input="message=$event.target.value"
>
```
**(2)作用在组件上**
在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件
**本质是一个父子组件通信的语法糖，通过prop和$.emit实现**。因此父组件 v-model 语法糖本质上可以修改为
```js
// 父组件
<aa-input v-model="aa"></aa-input>
// 等价于
<aa-input v-bind:value="aa" v-on:input="aa=$event.target.value"></aa-input>

// 子组件：
<input v-bind:value="aa" v-on:input="onmessage"></aa-input>

props:{value:aa,}
methods:{
    onmessage(e){
        $emit('input',e.target.value)
    }
}
```


## 7.data为什么是一个函数而不是对象
**核心原因**:避免多个组件实例共享同一份数据，导致数据污染
  - 若`data`是对象：所有组件实例会共享同一个对象的引用 → 改一个实例的 data，其他实例的 data 会同步变化（数据污染）；
  - 若`data`是函数：每次创建组件实例时，Vue 会执行该函数，返回一个「新的、独立的对象」→ 每个实例拥有专属的 data，互不干扰。

**底层逻辑**:对象是"引用类型",变量存储的是对象的内存地址，而非值本身

**简单回答**：因为对象是一个**引用类型**，如果 `data` 是一个对象的情况下会造成多个组件共用一个 `data`，`data`为一个函数，每个组件都会有自己的私有数据空间，不会干扰其他组件的运行。

## 8.Vue中key的作用是什么？
Vue中key的核心作用是作为虚拟 DOM 节点的唯一标识，帮助Vue的diff算法精准识别 DOM 节点的身份，从而优化渲染逻辑、避免渲染异常。
- 无key时，Vue 按「节点位置」就地更新，易导致 DOM 与数据不匹配
- 有 key 时，Vue 按 key 匹配新旧节点，仅复用 key 相同的节点，彻底避免因 “位置复用” 导致的渲染异常。

**为什么不建议用 index 作为 key?**
如果将数组下标作为 key 值，那么当列表发生变化时，可能会导致 key 值发生改变，从而引发不必要的组件重新渲染，甚至会导致性能问题。例如，当删除列表中某个元素时，其后面的所有元素的下标都会发生改变，导致 Vue 重新渲染整个列表。

## 9.watch 和 computed 有什么区别?
- 计算属性来描述依赖响应式状态的复杂逻辑
- watch用于每次响应式属性发生变化时的监听

## 10.ref和reactive的区别？
```ts
1. 使用场景不同：
   - ref主要用于基本类型
   const count = ref(0)
   
   - reactive用于对象类型
   const state = reactive({ count: 0 })

2. 访问方式不同：
   - ref需要.value
   console.log(count.value)
   
   - reactive直接访问
   console.log(state.count)

3. 解构行为不同：
   - ref保持响应性
   const { count } = useCount() // count是ref
   
   - reactive解构会失去响应性
   const { user } = userState // 失去响应性
```
## 11.如何处理响应式数据的常见问题？
尽量多使用ref而不是reactive
```ts
// 1. 解构响应式对象
// ❌ 错误方式
const { name, age } = reactive({ name: 'John', age: 30 })

// ✅ 正确方式
const state = reactive({ name: 'John', age: 30 })
const { name, age } = toRefs(state)

// 2. 数组响应式
// ❌ 错误方式
const list = reactive([1, 2, 3])
list[0] = 4 // 可能不会触发更新

// ✅ 正确方式
const list = ref([1, 2, 3])
list.value[0] = 4
```
## 12.Vue计算属性的函数名和data中的属性可以同名吗？为什么？
参考内容-[面试鸭](https://www.mianshiya.com/question/1817828876512944130)
不可以。因为 Vue 会将 data 中的属性和计算属性都挂载到 Vue 实例上，如果它们同名，则会发生命名冲突，导致实例中的属性被覆盖，从而引发不可预知的错误。

**扩展知识**:
**命名冲突的本质：在 Vue 中，data 和计算属性（computed）最终都会作为 Vue 实例的一个属性存在**。如果我们在 data 中定义了一个属性 foo，同时又在 computed 中定义了一个名为 foo 的计算属性，二者会产生命名冲突，Vue 会警告你存在重复定义。Vue 在初始化时会按照一定的顺序（如 Props、methods、data、computed、watch）将这些属性挂载到 Vue 实例上，后挂载的属性会覆盖先挂载的同名属性。
**计算属性的优先级：data 的优先级高于计算属性**。如果在 data 和计算属性中存在相同的属性，那么在模板中使用这些属性时，会优先使用 data 中的数据，因为 data 是直接存储数据的，而计算属性是基于 data 或其他属性的变化进行计算的。

## 13.如何在Vue中使用defineAsyncComponent实现异步组件加载？
异步组件的核心是按需加载：组件不会在页面初始化时加载，而是在需要渲染时（如首次显示、路由跳转）才通过网络请求加载，从而减小初始打包体积，提升首屏加载速度。

```js
import { defineAsyncComponent } from 'vue'
// 定义异步组件（简洁版）
const AsyncHello = defineAsyncComponent(() => import('./AsyncHello.vue'))
```

## 14.请简单介绍一下你对Vue的理解，包括它的特点和优势
Vue 是一款渐进式 JavaScript 框架，主要用于构建用户界面。它的核心库专注于视图层，并且易于与其他库或现有项目集成。

**Vue 的特点：**
- **1.响应式系统：**
  - Vue2基于`Object.defineProperty`实现数据劫持,通过`getter/setter`拦截属性操作，结合依赖收集（Dep）和派发更新（Watcher）实现响应式。
  - Vue3基于`Proxy`代理对象，直接拦截对象的增删改查操作，天然支持动态属性、数组下标变化和深层对象监听。
  - 数据变化自动驱动视图更新，无需手动操作 DOM。

- **2.组件化**
  - 什么是组件化,一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件
  降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求;提高可维护性，由于每个组件的职责单一

- **3.虚拟DOM与高效渲染**
  - **虚拟DOM**:通过 JS 对象模拟真实 DOM，减少直接操作真实 DOM 的代价。
  - **Diff算法**:对比新旧虚拟DOM的差异，最小化更新视图（如复用相同节点、按需更新属性）。

- **4.生命周期与Composition API**
  - **生命周期钩子**:created（组件实例创建）、mounted（DOM 挂载）、updated（数据更新）、unmounted（组件销毁）等。
  - **Composition API（Vue 3）**:通过 setup() 函数组织逻辑，替代 Options API，提升代码复用性和可读性。

## 15.Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决?
vue2是用`Object.defineProperty`实现数据响应式,如果是例如通过点击事件在data下的对象或数组内添加属性，能够触发setter与getter，但是无法触发事件属性的拦截。所以没有通过`Object.defineProperty`设置成响应式数据。

#### 解决办法
**1.Vue.set()**
原理是在set()内再次调用`defineReactive`方法,实现新增属性的响应式。在`defineReactive`内部还是通过`Object.defineProperty`实现属性拦截
```js
function defineReactive(obj, key, val) {
    Object.defineProperty(obj, key, {
        get() {
            console.log(`get ${key}:${val}`);
            return val
        },
        set(newVal) {
            if (newVal !== val) {
                console.log(`set ${key}:${newVal}`);
                val = newVal
            }
        }
    })
}
```
**使用方式**： Vue.set( target, propertyName/index, value )
其中`target`是目标对象/数组,`propertyName`对象的属性名,`value`是要设置的属性/元素值
```js
methods: {
  addAge() {
    // ❌ 直接新增：非响应式，视图不更新
    // this.user.age = 18;
    
    // ✅ 使用$set：新增属性并触发响应式
    this.$set(this.user, "age", 18);
  }
}
```
## 16.说说你对vue的mixin的理解，有什么应用场景？

> 官方定义，`mixin`（混入），提供了一种非常灵活的方式，来分发 `Vue` 组件中的可复用功能。

本质其实就是一个`js`对象，它可以包含我们组件中任意功能选项，如`data`、`components`、`methods`、`created`、`computed`等等。

我们只要将共用的功能以对象的方式传入 `mixins`选项中，当组件使用 `mixins`对象时所有`mixins`对象的选项都将被混入该组件本身的选项中来。

**使用场景**：

在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立。这时，可以通过`Vue`的`mixin`功能将相同或者相似的代码提出来。
在Vue中我们可以**局部混入**和**全局混入**。
::: code-group
```js [表单验证]
// mixins/validateMixin.js
//多个组件需要相同的工具方法,数据校验等,用 Mixin 封装
export default {
  methods: {
    // 通用手机号校验
    validatePhone(phone) {
      const reg = /^1[3-9]\d{9}$/;
      return reg.test(phone);
    },
    // 通用非空校验
    validateRequired(value) {
      return !!value.trim();
    }
  }
};
```
```js [局部混入]
<script>
import validateMixin from "./mixins/validateMixin.js";

export default {
  mixins: [validateMixin],
  methods: {
    submitForm() {
      if (!this.validatePhone(this.phone)) {
        alert("手机号格式错误");
        return;
      }
      // 提交逻辑
    }
  }
};
</script>
```
:::

**缺点**：
**命名冲突**，Mixin 与组件、多个 Mixin 之间的同名属性 / 方法易冲突，且冲突后排查困难；
**逻辑溯源难**：组件中使用的方法 / 数据无法直观判断来源
**耦合性高**：Mixin 与组件之间隐式依赖，修改 Mixin 可能影响所有使用的组件；

## 16.Vue常用的修饰符有那些，有什么应用场景？
🟢参考内容- [面试官：Vue常用的修饰符有哪些有什么应用场景](https://vue3js.cn/interview/vue/modifier.html#%E4%BA%8C%E3%80%81%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8)

在`Vue`中，修饰符处理了许多`DOM`事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理。

`vue`中修饰符分为以下五种：

- 表单修饰符
- 事件修饰符
- 鼠标按键修饰符
- 键值修饰符
- v-bind修饰符

#### **常用的事件修饰符**

1.`.stop`（阻止事件冒泡）

**核心作用**：阻止事件从子元素冒泡到父元素，避免父元素同类型事件被误触发

**语法**：`@事件名.stop="处理方法"`

```js
<!-- 点击按钮仅触发按钮事件，不会触发外层div的click -->
<div @click="handleDivClick">
  外层容器
  <button @click.stop="handleBtnClick">点击我</button>
</div>
```

2.`.prevent`（阻止默认行为）

**核心作用**：阻止 DOM 元素的默认行为（如 a 标签跳转、form 表单提交、回车键提交表单等）。

**语法**：`@事件名.prevent="处理方法"`

**示例**：

```js
<!-- 1. 阻止a标签默认跳转 -->
<a @click.prevent href="https://vuejs.org">点我不跳转</a>

<!-- 2. 阻止表单默认提交（改用自定义逻辑） -->
<form @submit.prevent="handleFormSubmit">
  <button type="submit">提交表单</button>
</form>
```

3.`.once`（事件仅执行一次）

**核心作用**：绑定的事件仅触发一次，后续重复触发无效

**语法**：`@事件名.once="处理方法"`

```js
<!-- 按钮仅第一次点击有效 -->
<button @click.once="handleFirstClick">仅点击一次</button>
```

4.`.enter`（回车按键修饰符）

**核心作用**：监听键盘「回车」键触发事件

**语法**：`@keyup.enter="处理方法"`

```js
<!-- 输入框按回车触发搜索 -->
<input 
  v-model="searchText" 
  @keyup.enter="handleSearch" 
  placeholder="输入后按回车搜索"
>
```

5.`.self`（仅自身触发事件）

**核心作用**：只有事件在当前元素**自身**触发时，才执行处理方法

**语法**：`@事件名.self="处理方法"`

```js
<!-- 只有点击div空白处才触发，点击子按钮不会触发（即使按钮事件没阻止冒泡） -->
<div @click.self="handleDivClick" style="padding: 20px; border: 1px solid #ccc;">
  我是父div
  <button @click="handleBtnClick">子按钮</button>
</div>
```

## 17.有写过自定义指令嘛？自定义指令的应用场景有哪些？
**参考内容**-[你有写过自定义指令吗？自定义指令的应用场景有哪些？](https://vue3js.cn/interview/vue/directive.html#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4)

注册一个自定义指令有全局注册与局部注册,**全局注册**主要是通过Vue.directive方法进行注册。
Vue自定义指令的核心价值是封装通用的DOM操作逻辑：Vue 推崇 “数据驱动视图”，但部分场景仍需直接操作DOM（如聚焦、滚动、样式控制），自定义指令能将这些跨组件复用的DOM逻辑抽离成可复用的指令，替代零散的`ref+DOM`操作，让代码更简洁、易维护。
::: code-group
```js [vue2模板]
// 1. 全局注册（main.js）
Vue.directive('指令名', {
  bind(el, binding) {}, // 指令绑定到元素（未插入DOM）
  inserted(el, binding) {}, // 元素插入DOM（最常用）
  update(el, binding) {} // 元素更新时
})

// 2. 局部注册（组件内）
export default {
  directives: {
    指令名: {
      inserted(el, binding) { /* 逻辑 */ }
    }
  }
}
```
```js [Vue3模板]
// 1. 全局注册（main.js）
import { createApp } from 'vue'
const app = createApp(App)
app.directive('指令名', {
  mounted(el, binding) {}, // 替代Vue2的inserted
  updated(el, binding) {}, // 元素更新
  unmounted(el) {} // 元素销毁（清理监听/定时器）
})

// 2. 局部注册（组件内）
<script setup>
const v指令名 = {
  mounted(el, binding) { /* 逻辑 */ }
}
</script>
```
:::

#### 最常用的几个场景
**1.输入框自动聚焦**
**痛点**：弹窗打开/页面加载时，需手动通过ref让输入框聚焦，逻辑零散；

**指令封装**：`v-focus` 自动让元素插入 DOM 后聚焦。

```js
<template>
  <input v-focus type="text" placeholder="自动聚焦">
  <!-- 弹窗内输入框也适用 -->
  <el-dialog v-model="showDialog">
    <input v-focus type="text">
  </el-dialog>
</template>

<script setup>
const vFocus = {
  mounted(el) {
    el.focus() // 元素插入DOM后立即聚焦
  }
}
</script>
```

**2.图片懒加载**

**痛点**：首屏加载大量图片导致性能差，第三方懒加载库体积大；

**指令封装**：`v-lazy` 监听图片是否进入视口，进入后再加载真实地址。

```js
<!-- 组件中使用 -->
<template>
  <img v-lazy="item.imgUrl" alt="商品图片" width="200" height="200">
</template>

<script setup>
// 全局注册（建议放main.js）
import { createApp } from 'vue'
const app = createApp(App)
app.directive('lazy', {
  mounted(el, binding) {
    const realSrc = binding.value // 真实图片地址
    el.src = 'https://xxx/placeholder.png' // 占位图

    // 监听元素是否进入视口（IntersectionObserver）
    const observer = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        el.src = realSrc // 加载真实图片
        observer.unobserve(el) // 停止监听，避免重复触发
      }
    })
    observer.observe(el)
  }
})
</script>
```

## 18.Vue的单向数据流和双向数据流
**(1)单向数据流**
在 Vue 中，单向数据流是指数据只能从父组件流向子组件。父组件通过 props向下传递数据给子组件，子组件接收后只能读取这些数据，不能直接修改从父组件传来的 props 数据 。这种数据流动方向是单一、不可逆的。

优势：
- 数据来源清晰，易于追踪。每个属性都有唯一的、明确的数据来源。
- 组件之间低耦合：子组件不依赖于父组件的内部实现
- 提高应用的可维护性：当应用出错时，更容易找到问题源头

**(2)双向数据流**
双向数据流允许数据在视图和数据模型之间双向流动。在 Vue 中，主要通过 v-model指令来实现。v-model 是语法糖，它结合了 :value 绑定（用于将数据模型的值绑定到视图）和 @input 事件监听（用于将视图的变化同步回数据模型 ）。


**(3)单向数据流与双向数据流绑定的关系**
单向数据流是组件通信的设计原则，确保数据只能从父组件流向子组件
双向绑定是数据与DOM之间的同步机制

## 19.vue实例在挂载中会发生什么？
**挂载的核心流程可概括为：**
```
解析挂载容器 → 模板编译（可选）→ 生成虚拟 DOM（VNode）→ 虚拟 DOM 转真实 DOM → 插入 DOM 树 → 触发生命周期钩子 → 建立响应式依赖
```

## 20.watch和watchEffect区别?
> 参考内容
> [watch和watchEffect区别](https://www.itcan.cn/2025/02/08/vue-watch-watcheffect/)

watch 和 watchEffect 是 Vue 3 中用于响应式数据监听的两种方式，它们的主要区别如下：
**1. 监听方式**
`watch`：需要显式指定要监听的数据源（一个或多个），并在数据变化时执行回调函数。
`watchEffect`：自动追踪回调函数中使用的响应式数据，无需显式指定监听源。

**2.回调触发时机**

- `watch`：默认在监听的数据变化后执行回调，可以通过 `immediate` 选项让回调在初始化时立即执行。
- `watchEffect`：在初始化时立即执行回调，并在其依赖的响应式数据变化时重新执行。

**3.依赖收集**

- `watch`：需要手动指定监听的数据源。
- `watchEffect`：自动收集回调函数中使用的响应式数据作为依赖。

**4.返回值**

- `watch`：无返回值。
- `watchEffect`：返回一个停止监听的函数。

**5.适用场景**

- `watch`：适合监听特定数据的变化并执行特定操作。
- `watchEffect`：适合在依赖的响应式数据变化时自动执行某些逻辑。

**示例代码**
::: code-group
```js [watch示例]
import { ref, watch } from 'vue';
 
const count = ref(0);
 
watch(count, (newValue, oldValue) => {
  console.log(`count changed from ${oldValue} to ${newValue}`);
});
 
count.value++; // 输出: count changed from 0 to 1
```
```js [watchEffect示例]
import { ref, watchEffect } from 'vue';
 
const count = ref(0);
 
watchEffect(() => {
  console.log(`count is: ${count.value}`);
});
 
count.value++; // 输出: count is: 1
```
:::
- `watch`：适合精确控制监听的数据和回调执行时机。
- `watchEffect`：适合自动追踪依赖并执行逻辑的场景。

## 21.如何理解reactive、ref、toRef和toRefs
> 基本类型用ref，对象/数组用reactive，解构用toRef/toRefs。
> ref是「万能」响应式 API，优先用于基本类型，需通过`.value`操作
> reactive是「对象 / 数组专属」的响应式API，直接操作属性；
> toRef/toRefs是「辅助工具」，解决reactive解构丢失响应式的问题，与原数据双向联动。

在 Vue 3 中，`reactive`、`ref`、`toRef`、`toRefs` 都是实现**响应式数据**的核心 API，但它们的适用场景、实现原理和使用方式有本质区别。

::: details 💡核心前提:响应式的本质
Vue 3 的响应式基于 Proxy（对象 / 数组）和`Object.defineProperty`（基本类型，ref 内部）实现，核心是拦截数据的读取 / 修改操作，并在数据变化时触发视图更新。
- 对于对象/数组：用 Proxy 递归代理所有属性，拦截 `get/set`；
- 对于基本类型（string/number/boolean 等）：无法直接用 Proxy（因为基本类型是值类型，不是引用类型），需用「包装对象」（ref的 .value）间接实现。
:::

**1.`reactive`：对象/数组的响应式**
用于创建**对象/数组**类型的响应式数据，基于 Proxy 实现，会递归代理对象的所有嵌套属性。

**特点**:
- 仅支持对象/数组，不能代理基本类型。
- 直接解构会丢失响应式

**2.`ref`:万能的响应式**

用于创建任意类型的响应式数据（基本类型/对象/数组），是Vue3最常用的响应式API。
- 对于基本类型：用`Object.defineProperty`包装成「带 .value 的对象」
- 对于对象 / 数组：内部会自动用`reactive`包装，本质还是`Proxy`

**3.`toRef`:单个属性的响应式联动**
基于已有响应式对象的某个属性，创建一个 ref，且该ref与原对象属性双向联动。
解决从`reactive`对象中单独提取某个属性，且要保留响应式的问题。

**4.`toRefs`:批量转换响应式属性**
把整个响应式对象转换成一个普通对象，该普通对象的每个属性都是对应的`toRef`。每个属性都是ref，需通过`.value`访问/修改

| 特性           | reactive                 | ref                      | toRef                    | toRefs                   |
| -------------- | ------------------------ | ------------------------ | ------------------------ | ------------------------ |
| 支持数据类型   | 仅对象 / 数组            | 所有类型（优先基本类型） | 基于响应式对象的单个属性 | 基于响应式对象的所有属性 |
| 访问方式       | 直接访问属性（无.value） | script 中需.value        | 需.value                 | 需.value                 |
| 解构响应式     | 丢失                     | 丢失（解构.value）       | 保留（单个属性）         | 保留（所有属性）         |
| 与原数据联动性 | 自身就是响应式源         | 对象类型内部联动         | 双向联动                 | 双向联动                 |
| 适用场景       | 复杂对象 / 数组          | 基本类型 / 独立对象      | 单独提取一个响应式属性   | 批量解构响应式对象       |

**最佳实践**
1.**用`reactive`**：定义复杂的对象/数组（如表单数据、列表数据），且不需要解构时。
```js
const form = reactive({ username: '', password: '' }) // 表单数据
const list = reactive([{ id: 1, text: '任务1' }]) // 列表数据
```
2.**用ref**：定义基本类型（count/flag）、需要单独引用的对象（弹窗实例）、或不确定数据类型时。
```js
const count = ref(0) // 数字
const isShow = ref(false) // 布尔值
const dialogRef = ref(null) // 组件实例（如Element Plus弹窗）
```
3.**用toRef**：只需要响应式对象的某一个属性，且要保持联动时。
```js
const user = reactive({ name: '张三', age: 18 })
const name = toRef(user, 'name') // 仅需name属性，且保留响应式
```
4.**用toRefs**：组合式函数（Composables）返回响应式对象，方便外部解构使用。
```js
// 组合式函数 useUser.js
export const useUser = () => {
  const user = reactive({ name: '张三', age: 18 })
  // 返回时用toRefs，外部解构不丢响应式
  return toRefs(user)
}

// 组件中使用
const { name, age } = useUser()
```
## 22.路由的 hash 和 history 模式的区别

**hash 模式**：开发中默认的模式，地址栏URL后携带#，后面为路由。#号后面的内容不会发送到服务器。

**history 模式**：history 模式中URL没有#，这样相对hash模式更好看，但是需要后台配置支持。

## 23.面试watch和created的执行顺序，加入immediate后区别
`created` → 组件数据初始化完成 → watch 仅在数据首次赋值后、后续变化时触发（首次不会执行）

加入`immediate: true`后的执行顺序:
1.组件实例化，初始化 props/data 响应式数据；
2.初始化watch监听器，因`immediate: true`，立即执行一次回调函数（此时 created 还未执行）
3.执行 created 钩子；
4.后续数据源变化时，watch仍会正常触发。

## 24.怎么修改组件样式？
Vue修改组件样式分为三类--全局样式(作用于全部组件)、局部样式(隔离当前组件)、动态样式(根据状态切换)


## 25.Vue双向绑定原理
vue2中，利用的是Object.definePropety去劫持对象的访问器（getter、setter），当对象属性发生变化时可以获取变化，然后根据变化来作后续响应。Vue3中则是通过proxy来进行类似的操作。

## 26.对spa单页面的理解，它的优缺点分别是什么
SPA仅在web页面初始化时加载相应的html、js、css。一旦页面加载完成，SPA不会因为用户的操作而进行页面重新加载或跳转；取而代之的时利用路由机制实现HTML内容的变换，UI与用户的交互，避免应用的重新加载。
**优点**：1.用户体验好，内容的改变不重新加载整个页面，避免了不必要的跳转和重复渲染。2.对服务器压力小。3.前后端职责分离，框架清晰，前端进行交互逻辑，后端负责数据处理。
**缺点**：1.初次加载耗时多。2.前进后退路由管理：由于单页面应用在一个页面中显示所有内容，所有不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理。3.SEO难度大。

## 27.说一下对vuex的理解?
Vuex是Vue应用的集中式状态管理库,用于集中管理应用中的共享状态。vuex中有几个核心属性：
1.state：存储应用的状态数据，类似data。

2.getter：从state中派生出计算属性，类似组件的computed

3.mutations：唯一修改State的方式，必须是同步函数。类似methods

4.actions：用于处理异步操作（如api请求），通过dispatch触发。

5.modules：将store分割成模块，便于管理大型项目。

工作流程：

组件通过dispatch调用action，action执行异步操作后，通过commit调用mutation，然后mutation修改state，state更新后，触发组件的重新渲染

::: details 使用示例
```js
// store/index.js
import Vue from 'vue';
import Vuex from 'vuex';
import axios from 'axios';

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    count: 0,
    user: null
  },
  getters: {
    doubleCount: state => state.count * 2
  },
  mutations: {
    increment(state) {
      state.count++;
    },
    setUser(state, payload) {
      state.user = payload;
    }
  },
  actions: {
    async fetchUser({ commit }) {
      const res = await axios.get('/api/user');
      commit('setUser', res.data);
    }
  },
  modules: {}
});
```
**组件中使用：**
```js
export default {
  computed: {
    count() {
      return this.$store.state.count;
    },
    doubleCount() {
      return this.$store.getters.doubleCount;
    }
  },
  methods: {
    increment() {
      this.$store.commit('increment');
    },
    fetchUser() {
      this.$store.dispatch('fetchUser');
    }
  }
};
```
:::
