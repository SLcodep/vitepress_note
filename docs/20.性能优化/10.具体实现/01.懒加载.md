---
title: 懒加载
date: 2025-11-27 17:24:35
permalink: /performance/lazy
# titleTag: 
categories:
  - 性能优化
tags:
  - 性能优化
---



懒加载分为：**数据懒加载**和**图片懒加载**
核心思想是**延迟加载非关键资源**，只在需要时加载它们。
- **按需加载** ,避免加载当前用不到的资源，减少首屏 HTTP 请求数、降低首屏加载时间 
- **时机触发** ,触发加载的核心条件是资源即将被使用

## 懒加载和预加载

## 图片懒加载

**具体表现**：当我们访问页面时，先将img图片的路径替换成一张占位图的路径，这样就只需请求一次，而当图片进入可视区域时才把其图片的路径替换为真正的路径，从而显示图片，达到懒加载的效果。(即：懒加载就是使用同一张占位图进行占位，然后按需获取图片真正的路径，从而实现懒加载)

**技术原理**是：先将img的src属性隐藏，而将其真正的地址存放在img标签自定义的属性中(eg：data-src)，当图片进入可视区域时，将真正的路径从data-src中取出替换回来，从而显示图片。

**1.原生JS实现**

`window.innerHeight`:是浏览器当前窗口的高度
`img.getBoundingClientRect().top`:图片顶部到可视区域顶部的距离(用来判断图片是否进入视口)

HTML中的写法
`<img data-src="真实图片地址.jpg" alt="懒加载图片">`

```js
// 1. 获取页面所有img标签
const images = document.querySelectorAll('img');

// 2. 监听页面滚动事件
window.addEventListener('scroll', (e)=>{
  // 3. 遍历每个图片
  images.forEach(image=>{
    // 4. 计算图片顶部到可视区域顶部的距离
    const imageTop = image.getBoundingClientRect().top;
    // 5. 判断：如果图片顶部进入了可视区域（距离 < 可视高度）
    if(imageTop < window.innerHeight){
      // 6. 从data-src（存真实图片地址的自定义属性）中取地址，赋值给src（触发加载）
      const data_src = image.getAttribute('data-src');
      image.setAttribute('src', data_src)
    }
  })
})
```

**2.IntersectionObserver 实现方式**
**核心工具**：`IntersectionObserver`
浏览器提供的 API，能自动监听元素是否进入视口，不用手动监听滚动、计算位置，性能更优。

Vue中img的写法
`<img v-lazyload="真实图片地址.jpg" alt="懒加载图片">`

```js
// 1. 全局注册Vue自定义指令v-lazyload
Vue.directive('lazyload', {
  // 2. 当指令绑定的元素（img）插入DOM时执行
  inserted(el, binding){
    // el：指令绑定的img元素；binding.value：指令传的参数（真实图片地址）
    const placeholder = '占位图地址'; // 先显示占位图
    el.src = placeholder;

    // 3. 创建IntersectionObserver实例，监听元素是否进入视口
    const observer = new IntersectionObserver((entries, observer)=>{
      entries.forEach(entry=>{
        // 4. 如果元素进入视口（isIntersecting为true）
        if(entry.isIntersecting){
          // 5. 把真实地址赋值给src，触发加载
          el.src = binding.value;
          // 6. 加载完成后，停止监听这个元素（避免重复触发）
          observer.unobserve(el);
        }
      })
    },{rootMargin: '100px'}) // 提前100px触发（让图片进入视口前就开始加载）

    // 7. 开始监听当前img元素
    observer.observe(el);
  }
})
```
