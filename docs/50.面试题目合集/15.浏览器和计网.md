---
title: 浏览器和计网面试
date: 2025-12-25 17:58:41
permalink: /qianduan/浏览器和计网面试
categories:
  - 前端
  - javascript
tags:
  - javascript
---

<CollapsibleToc 
  title="快速导航" 
  :defaultOpen="true" 
  :minLevel="1" 
  :maxLevel="3" 
/>

# 浏览器篇 
## 1.浏览器输入URl后发生了什么？
参考内容-- [浏览器输入URL后发生什么？](https://jonny-wei.github.io/blog/base/browser/browser-start.html#%E8%BE%93%E5%85%A5%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86)

浏览器输入URL后核心分7步,整体是**解析→连接→请求→响应→渲染**的逻辑
**1.URL解析与校验**,浏览器校验URL格式，解析出协议、域名、端口
**2.DNS域名解析,**分成发送到网络进程、检查缓存、DNS解析
**3.建立TCP连接**:通过三次握手建立客户端与服务器的TCP连接(HTTPS还需TLS/SSL 握手，验证证书、加密通信)
**4.发送HTTP请求**:浏览器构建HTTP请求（请求行、请求头、请求体），通过TCP连接发送到服务器
**5.服务器处理请求**:服务器接收请求，处理业务逻辑，返回 HTTP 响应（状态码、响应头、响应体）
**6.关闭TCP连接**:通过四次挥手关闭TCP连接（HTTP/1.1 默认开启 Keep-Alive，可复用连接）
**7.页面渲染**:浏览器解析响应体（HTML→DOM 树、CSS→CSSOM 树），结合生成渲染树，布局（Layout）、绘制（Paint）、合成（Composite）后展示页面。

## 2.对浏览器缓存机制的理解？
::: details 💡怎么理解浏览器缓存和存储的区别？
- **浏览器缓存**
  浏览器缓存的核心目标是提升网页加载速度，减少服务器请求；第一次请求资源时，浏览器下载并保存到本地；第二次请求时，先检查本地缓存是否有效，有效则直接使用本地资源，无需请求服务器。

- **浏览器存储**
  浏览器存储核心目标是持久化存储前端数据，支持业务逻辑；用于存储前端业务数据，由 JavaScript 主动操作，数据是结构化的键值对或对象。

  | 特性         | 浏览器缓存（Browser Cache）            | 浏览器存储（Browser Storage）        |
  | ------------ | -------------------------------------- | ------------------------------------ |
  | **核心目标** | 提升网页加载速度，减少服务器请求       | 持久化存储前端数据，支持业务逻辑     |
  | **数据来源** | 服务器返回的静态资源（JS/CSS/ 图片）   | 前端 JS 主动写入的业务数据           |
  | **管理主体** | 浏览器自动管理，开发者可配置规则       | 开发者完全控制，通过 API 读写        |
  | **生命周期** | 由 HTTP 缓存头（如 Cache-Control）控制 | 由开发者手动清理或按存储类型规则失效 |

  :::

浏览器缓存是前端性能优化的核心手段，核心分为强缓存和协商缓存两层，采用先强后协商的优先级。
1.强缓存:通过`Cache-Control`或`Expires`控制,缓存未过期时直接从本地磁盘 / 内存读取资源，完全不发起网络请求，性能最优；
2.协商缓存:强缓存失效后触发，浏览器发送请求到服务器,通过`ETag/If-None-Match`（精准）或`Last-Modified/If-Modified-Since`对比资源是否更新,未更新则返回 304 状态码（复用本地缓存），更新则返回200+新资源；
最终目的是减少网络请求、降低服务器压力、提升页面加载速度。

| 维度             | 强缓存（磁盘缓存）                       | 协商缓存（磁盘缓存）                                            |
| ---------------- | ---------------------------------------- | --------------------------------------------------------------- |
| **核心目标**     | 完全避免网络请求，极致提速               | 确认资源是否更新，兼顾缓存和新鲜度                              |
| **判断主体**     | 仅浏览器本地（无服务器参与）             | 浏览器 + 服务器（需要发请求）                                   |
| **判断依据**     | `Cache-Control`（主流）、`Expires`       | `ETag/If-None-Match`（优先）、`Last-Modified/If-Modified-Since` |
| **网络请求特征** | 无请求（Status Code 无）                 | 有请求，但资源未更新时无响应体（Status Code 304）               |
| **适用场景**     | 长期不变的静态资源（如第三方库、logo）   | 可能更新的静态资源（如业务 JS/CSS）                             |
| **更新问题**     | 过期前无法主动更新，需靠 “资源指纹” 规避 | 资源更新后服务器会返回新内容，自动更新缓存                      |

### 2.1 协商缓存和强缓存的区别?
强缓存和协商缓存是浏览器缓存的两个核心层级，核心区别在于是否发起**网络请求**和**校验逻辑**:
  1.强缓存:缓存未过期时直接从本地读取资源，完全不发网络请求
  2.协商缓存:强缓存失效后触发，必须发请求到服务器，校验资源是否更新,未更新返回 304（复用本地缓存），更新则返回 200 + 新资源，能保证资源最新。


## 3.浏览器本地存储方式及使用场景?
浏览器核心本地存储有4种：`Cookie`、`localStorage`、`sessionStorage`、`IndexedDB`,核心按 “存储大小、生命周期、是否与服务器交互” 选型：
**1.Cookie**（~4KB）：可设置过期时间，**会随HTTP请求携带到服务器**，适合存储登录态、用户标识等需和后端交互的少量数据；
**2.localStorage**（~5MB）：**永久存储**（手动删除才清空），仅客户端存储，适合存储用户偏好（如主题）、离线缓存的少量持久数据；
**3.sessionStorage**（~5MB）：会话级存储（关标签页即清空），**标签页隔离**，适合存储临时表单、页面间临时传值等短期数据；
**4.IndexedDB**（大容量）：NoSQL 数据库，适合存储大量结构化数据（如离线应用的聊天记录、商品列表）。

| 存储方式       | 存储大小 | 生命周期               | 核心特性                     | 典型使用场景                                                                    |
| -------------- | -------- | ---------------------- | ---------------------------- | ------------------------------------------------------------------------------- |
| Cookie         | ~4KB     | 可设置过期时间         | 随 HTTP 请求自动携带到服务器 | 1. 存储登录 token / 用户 ID；2. 记住密码；3. 后端需要的用户标识                 |
| localStorage   | ~5MB     | 永久（手动删除）       | 仅客户端，同域名共享         | 1. 用户主题 / 语言设置；2. 离线缓存的静态数据；3. 搜索历史（持久）              |
| sessionStorage | ~5MB     | 会话级（关标签页清空） | 仅客户端，标签页隔离         | 1. 未提交的表单数据；2. 页面跳转的临时参数；3. 临时的页面状态                   |
| IndexedDB      | 几十 MB+ | 永久（手动删除）       | 仅客户端，支持结构化数据     | 1. 离线应用的大量数据（如电商商品列表）；2. 聊天记录缓存；3. 大数据量的本地查询 |

------

### 3.1cookie、localStorage、SessionStorage区别？
Cookie、localStorage、sessionStorage 是浏览器最常用的三种本地存储，核心区别集中在存储大小、生命周期、与服务器交互、作用域四个维度

| 对比维度     | Cookie                    | localStorage            | sessionStorage          |
| ------------ | ------------------------- | ----------------------- | ----------------------- |
| 存储大小     | ~4KB                      | ~5MB                    | ~5MB                    |
| 生命周期     | 可设置过期时间（如 1 天） | 永久（手动删除）        | 会话级（关标签页删）    |
| 与服务器交互 | 随 HTTP 请求自动携带      | 仅客户端，不携带        | 仅客户端，不携带        |
| 作用域       | 同域名下共享              | 同域名下共享            | 仅当前标签页（隔离）    |
| 数据类型     | 字符串                    | 字符串（需手动转 JSON） | 字符串（需手动转 JSON） |
| 核心使用场景 | 登录态、用户标识          | 持久化偏好（主题）      | 临时表单、页面传值      |


## 4.浏览器的渲染过程？

**1.构建DOM树：**将 HTML 文本解析为浏览器能理解的节点树结构，保留 HTML 的层级关系
**2.构建CSSOM树**：将 CSS 样式解析为结构化的样式规则树。
**3.构建渲染树**：根据 DOM 树和 CSSOM 规则树构建渲染树
**4.布局**：根据渲染树，计算每个元素的几何属性，包括宽高、位置、内外边距等。输出布局树
**5.绘制**：根据布局树和元素样式，将每个元素绘制到屏幕的像素点上，包括颜色、背景、边框、阴影等。
**6.合成**：将所有绘制好的图层合并为最终的屏幕图像，并发送到显卡显示。

------

### 4.1 浏览器渲染优化？
浏览器渲染优化围绕**减少渲染阻塞**、**避免不必要的重排重绘**、**提升合成效率**三个核心方向：

1.解决 HTML/CSS/JS 的渲染阻塞问题，让关键资源优先加载；
2.减少重排（回流）和重绘，比如避免频繁操作 DOM、使用离线 DOM 或 CSS 触发合成属性；
3.优化合成阶段，利用 GPU 加速，合理拆分图层，降低绘制复杂度。

- **(1)针对JavaScript**
JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。
`<script>`有三种引入资源的方式，直接引入、async属性和defer属性。
`script`:立即停止页面渲染去加载资源文件,当资源加载完毕后立即执行js代码
`async`:下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；
`defer`:是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。

- **(2)避免不必要的重排（回流）和重绘**
重排:元素的几何属性（宽高、位置、尺寸）变化，导致浏览器重新计算布局，代价极高
重绘：元素的外观属性（颜色、背景、阴影）变化，无需重新布局，代价低于重排；
合成：仅改变元素的合成属性（transform、opacity），直接由 GPU 处理，代价最低。
1.避免频繁操作 DOM
2.使用CSS触发合成属性
3.使用绝对定位脱离文档流

- **(3)优化合成阶段**
浏览器会将页面拆分为多个图层，GPU 并行渲染，图层管理不当会增加渲染开销。

## 5.对事件循环的理解?
事件循环（Event Loop）是 S实现异步编程的核心机制，因为JS是单线程的，通过事件循环协调同步任务、微任务、宏任务的执行顺序

1.同步任务优先执行，执行完后清空当前所有微任务；
2.微任务执行完毕后，触发一次页面渲染（可选），再从宏任务队列中取一个任务执行；
3.重复上述过程，形成 循环

`Promise.then/async/await` 属于微任务，`setTimeout/DOM事件`属于宏任务；

------

### 5.1浏览器和 Node.js 事件循环的核心差异
1.微任务优先级：Node.js中`process.nextTick`优先级高于普通微任务（如 Promise），浏览器无此特殊微任务；
2.宏任务类型与执行阶段:Node.js中宏任务有阶段划分，`timers、I/O、check`等阶段执行宏任务;浏览器无阶段划分，按队列顺序取一个执行；
3.渲染环节:浏览器事件循环包含页面渲染步骤，Node.js 无渲染环节，仅处理异步任务。

------

### 5.2宏任务和微任务分别有哪些

| 任务类型   | 浏览器环境                                                                                                                                                                                            | Node.js 环境                                                                                                                                                   | 关键备注                                                                             |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| **微任务** | 1. Promise.then/catch/finally2. async/await（本质是 Promise）3. queueMicrotask()4. MutationObserver（监听 DOM 变化）                                                                                  | 1. process.nextTick（优先级最高）2. Promise.then/catch/finally3. queueMicrotask()                                                                              | async/await 的 await 后面代码属于微任务；Node 中 process.nextTick 比普通微任务先执行 |
| **宏任务** | 1. setTimeout/setInterval2. DOM 事件（click/load/resize 等）3. XMLHttpRequest/AJAX 请求回调4. requestAnimationFrame（渲染前执行，优先级高于普通宏任务）5. script 标签（整体代码，可视为最外层宏任务） | 1. timers 阶段：setTimeout/setInterval2. I/O 阶段：文件读写、网络请求回调3. check 阶段：setImmediate4. close 阶段：socket 等关闭回调5. script 标签（整体代码） | requestAnimationFrame 仅浏览器有；setImmediate 仅 Node 有；script 整体是第一个宏任务 |

## 6.V8的垃圾回收机制是怎样的？
V8垃圾回收的核心是分代回收：将内存分为新生代（短期存活对象）和老生代（长期存活对象），分别用不同算法提升回收效率；
1.新生代：用Scavenge 算法（复制 + 清理），将内存分为 From/To 空间，存活对象复制到 To 空间，清理 From 空间，存活2次的对象晋升到老生代；
2.老生代：用标记-清除+标记-整理+增量标记+并发标记，先标记存活对象，清除未标记对象，再整理内存碎片，通过增量 / 并发标记减少主线程阻塞；


## 如何判断前端是否进行了跨域操作的解决？

**1.打开浏览器开发者工具-Network面板**
找到跨域请求的那一行,查看`Request Headers`是否包含：`Origin: http://frontend.com`。这个是浏览器自动加的，用来告诉服务器当前请求来自哪个域。
如果请求是**非简单请求**（比如带自定义 header、POST JSON），浏览器会先发一个`OPTIONS`预检请求。
查看是否有 `OPTIONS` 请求记录,如果 OPTIONS 没有返回允许跨域的响应头，真正的请求不会被发送。

- 只要能在Network面板看到浏览器发出了请求，就说明前端已经正确触发了跨域请求。

- **后端的判断**

**1.看浏览器控制台错误信息**
常见错误
```js
Access to fetch at 'http://backend.com/api/data' from origin 'http://frontend.com' 
has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present 
on the requested resource.
```

**2.查看响应头（Response Headers）**

Network 面板，点击跨域请求，Response Headers 是否包含
```js
Access-Control-Allow-Origin: *
或
Access-Control-Allow-Origin: http://frontend.com
```

| 检查点                                              | 前端问题                 | 后端问题               |
| --------------------------------------------------- | ------------------------ | ---------------------- |
| 请求是否发出（Network）                             | 没发请求 / URL 错        | 发了但被浏览器拦截     |
| Request Headers 是否有 Origin                       | 无（前端没正确触发跨域） | 有，但后端没返回允许头 |
| Response Headers 是否有 Access-Control-Allow-Origin | -                        | 没有就是后端问题       |
| OPTIONS 请求是否成功返回允许的 Method/Headers       | -                        | 没返回就是后端问题     |



# 计算机网络
## 1.get和post请求的区别？
`GET`和`POST`是HTTP协议中最常用的两种请求方法，核心区别体现在请求参数位置、数据大小、安全性、缓存性。

**1.参数位置**:GET 参数拼在 URL 后（查询字符串），POST参数放在请求体中；
**2.数据限制**:GET受URL长度限制(一般几KB),POST 无明确大小限制；
**3.语义用途**:GET用于**获取数据**(只读),POST 用于**提交数据**(会修改服务器状态)
**4.安全性**：GET的参数暴露在URL，安全性较低；POST参数在请求体中，安全性相对较高。
**5.缓存性**：浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。

## 2.常见的HTTP请求方法

- GET:向服务器获取数据。
- POST:将实体提交到指定的资源，通常会造成服务器资源的修改。
- PUT:上传文件，更新数据
- DELETE:删除服务器上的对象
- HEAD:获取报文首部，与GET相比，不返回报文主体部分
- OPTIONS：询问支持的请求方法，用来跨域请求；
- CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信
- TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。

## 3.HTTP 1.0 和 HTTP 1.1 之间有哪些区别？
HTTP 1.1 是对 HTTP 1.0 的增强与优化,核心解决了 1.0 性能低下、连接效率低、缓存策略不完善等问题。

**1.连接管理**：1.0 默认短连接（每次请求都要新建 TCP 连接），1.1 引入长连接（Keep-Alive） 作为默认值，复用 TCP 连接提升效率；
**2.缓存机制**：1.1 新增 Cache-Control 等字段，替代 1.0 简单的 Expires，实现更精细的缓存控制；
**3.带宽优化**：1.1 支持断点续传（Range 请求） 和分块传输编码，减少带宽浪费；
此外1.1还新增PUT/DELETE/OPTIONS/TRACE/CONNECT 等请求方法。

## 4.HTTP 1.1 和 HTTP 2.0 的区别？
HTTP 2.0 是基于 HTTP 1.1 的性能升级版本，核心解决了 1.1 的队头阻塞问题，同时通过多路复用、二进制帧、头部压缩等特性大幅提升传输效率。
::: details 解决队头阻塞
- **问题**
HTTP 1.1 长连接下，同一 TCP 连接的请求按顺序响应，请求是**串行响应**的：比如客户端发送 `请求A→请求B→请求C`，服务器必须按顺序返回 `响应A→响应B→响应C`，若 响应A 耗时久，B和C只能等待（队头阻塞）。
- **多路复用**
HTTP 2.0 把每个请求/响应封装为独立的流，每个流有唯一的 流 ID，服务器可乱序返回不同流的帧，客户端再根据流ID重组数据，**实现一个TCP连接内的并发传输**。
:::

**1.传输格式**：1.1 是文本格式，2.0 是二进制帧格式，解析更高效、错误更少；
**2.连接复用**：1.1 长连接下仍按请求顺序响应（队头阻塞），2.0 支持多路复用，一个 TCP 连接并发传输多个请求 / 响应；
**3.头部优化**：2.0 引入HPACK算法压缩请求头，减少冗余字段传输；

## 5.HTTP和HTTPS协议的区别?
HTTP 和 HTTPS 的核心差异在于安全性，HTTPS 是 HTTP 基于 TLS/SSL 协议的加密版本，解决了 HTTP 明文传输的安全隐患。
HTTP和HTTPS的**核心区别是是否加密传输**:

1.传输安全：HTTP 明文传输，数据可被窃听、篡改；HTTPS 基于 TLS/SSL 加密传输，数据隐私和完整性有保障；
2.端口与协议：HTTP 默认端口 80，无加密层；HTTPS 默认端口 443，在 HTTP 和 TCP 之间增加了 TLS/SSL 加密层；
3.证书要求：HTTPS 需 CA 机构颁发的 SSL 证书，验证服务器身份；HTTP 无证书要求；

::: details HTTPS的加密核心原理
**HTTPS的加密核心原理（握手过程）**
HTTPS 并非全程非对称加密,而是非对称加密 + 对称加密结合:
**1.握手阶段（非对称加密）:**
- 客户端向服务器索要并验证 SSL 证书，确认服务器身份；
- 客户端生成一个随机的对称密钥，用服务器证书中的公钥加密后发送给服务器；
- 服务器用私钥解密，得到对称密钥。

**2.传输阶段（对称加密）:**
- 后续所有HTTP请求/响应数据，都用这个对称密钥加密传输，兼顾安全和效率。
:::

## 6.HTTP请求报文的是什么样的？
参考内容-[说说你理解的HTTP request 报文结构是怎样的？](https://www.cnblogs.com/ai888/p/18607553)
HTTP 请求报文由四部分构成,顺序不可变:

**1.请求行**：必选，包含请求方法、请求 URL、协议版本，是报文的核心起始部分
**2.请求头**：可选，由多个 Key: Value 键值对组成，传递请求的附加信息（如客户端类型、接受的数据格式）；
**3.空行**：必选，一个仅包含回车换行（\r\n）的空行，用于分隔请求头和请求体；
**4.请求体**：可选，承载需要发送给服务器的数据（如 POST 请求的参数、表单数据），GET 请求一般无请求体。

## 7.HTTP响应报文的是什么样的？
参考内容 - [请求报文和响应报文详解](https://c.biancheng.net/view/nt1bmq4.html)
响应报文有4部分组成：

**1.状态行**：必选，包含协议版本、状态码、状态描述，用于告知客户端请求的处理结果；
**2.响应头**：可选，由多个 Key: Value 键值对组成，传递响应的附加信息（如服务器类型、响应数据格式、缓存规则）；
**3.空行**：必选，仅包含回车换行（\r\n），用于分隔响应头和响应体；
**4.响应体**：可选，承载服务器返回的具体数据（如 HTML 页面、JSON 数据、图片二进制流）。

::: details 详细内容
- **1.状态行（Status Line）**
  **格式**:协议版本 状态码 状态描述\r\n,如`HTTP/1.1 200 OK`。

- **2.响应头（Response Headers）**
  **格式**：`Header-Name: Header-Value\r\n`，可有多行，每行一个键值对，用于传递响应的元信息。

  | 常见响应头       | 作用                                | 示例                                                                                      |
  | ---------------- | ----------------------------------- | ----------------------------------------------------------------------------------------- |
  | `Server`         | 标识服务器软件类型                  | `Server: nginx/1.21.6`                                                                    |
  | `Content-Type`   | 响应体的数据格式和编码              | `Content-Type: application/json; charset=utf-8`、`Content-Type: text/html; charset=utf-8` |
  | `Content-Length` | 响应体的字节长度                    | `Content-Length: 128`                                                                     |
  | `Cache-Control`  | 控制缓存策略                        | `Cache-Control: max-age=3600`                                                             |
  | `Location`       | 重定向的目标 URL（配合 3xx 状态码） | `Location: https://www.example.com/new`                                                   |
  | `ETag`           | 资源的唯一标识（用于协商缓存）      | `ETag: "abc123"`                                                                          |

:::

------

### 7.1HTTP 状态码分为几类？常见的 2xx/3xx/4xx/5xx 分别代表什么？
**2xx（成功）**：200（请求成功）、204（成功但无响应体）；
**3xx（重定向 / 缓存）**：301（永久重定向）、302（临时重定向）、304（协商缓存命中，用本地缓存）；
**4xx（客户端错误）**：400（请求参数错误）、401（未登录）、403（无权限）、404（资源不存在）；
**5xx（服务器错误）**：500（服务器内部错误）、502（网关错误）、504（网关超时）。

## 8.TLS/SSL的工作原理?
> HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。
::: details HTTPS的工作过程
1.**客户端发起SSL连接请求**：当用户通过浏览器访问HTTPS网站时，浏览器会向服务器发起SSL连接请求。
2.**服务器响应并发送公钥证书**：服务器收到请求后，会向客户端发送包含公钥的数字证书。这个证书由可信的证书颁发机构（CA）签发，用于验证服务器的身份。
3.**客户端验证证书**：客户端浏览器会验证证书的有效性，包括检查证书是否由受信任的CA签发、证书是否过期、证书中的域名是否与访问的网址一致等。
4.**生成对称加密密钥并加密传输**：验证通过后，客户端会生成一个随机对称加密密钥，并使用服务器公钥加密这个密钥，然后发送给服务器。只有服务器拥有对应的私钥才能解密这个密钥。
5.**安全通信**：服务器使用私钥解密出对称加密密钥后，双方就可以使用这个密钥对数据进行加密和解密，实现安全通信。
![https流程](/public/qian/https流程.png)
:::

## 9.DNS完整的查询过程？
> DNS的作用是什么？将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。
> 试想一下在图书馆中，如此多的图书，如何查找？工具类-计算机类-《Vue原理》-3楼A区B排C行
> 所以也就能理解为什么请求顺序是根域名服务器、顶级域服务器、权威域名服务器
> 根域名服务器是 DNS 系统的最高层级，全球共 13 组，负责管理所有顶级域（如 `.com` `.cn` `.org`）
> 顶级域服务器（如 `.com` 服务器）负责管理该顶级域下的所有二级域名（如 `baidu.com`）

- **回答**
1.首先会在浏览器缓存中查找对应的IP地址，如果查找到就直接返回，找不到就继续下一步。 
2.将请求发送给本地DNS服务器，在本地域名服务器缓存中查询 
3.本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址。 
4.本地DNS服务器向顶级域名服务器发送请求。 
5.本地DNS服务器向权威域名服务器发送请求。

## 10.TCP与UDP的区别？
TCP 和 UDP 是传输层的两大核心协议，TCP 面向连接、可靠传输；UDP 无连接、不可靠传输。
TCP 是面向连接的可靠传输协议，通过三次握手、重传、拥塞控制保证数据准确送达，但速度慢；UDP 是无连接的不可靠传输协议，无额外开销、速度快、实时性高，但不保证数据可靠性和安全性。


## 11.三次握手如果中断了会发生什么？
TCP 三次握手任一阶段中断，连接都无法建立，核心处理逻辑是**超时重传 + 放弃建立**：

**第一次握手中断**：客户端发送 `SYN` 后未收到 `SYN+ACK`，超时后重传 `SYN`，达到重传次数上限则终止连接；
**第二次握手中断**：服务器发送 `SYN+ACK `后未收到 `ACK`，超时重传 `SYN+ACK`，超时后关闭半连接；客户端未收到 `SYN+ACK`，行为同第一次握手中断；
**第三次握手中断**：客户端发送 `ACK` 后丢失，服务器未收到则超时重传 `SYN+ACK`，客户端收到重复包后再次发送 `ACK`；若仍无响应，服务器关闭连接，客户端则认为连接已建立，发送数据时触发超时重传。

>**不要认为第三次握手中断后连接完全无效**：客户端会认为连接已建立，直到发送数据时收到 RST 或超时，才会发现连接失败；

## 12.WebSocket？
websocket是一种基于TCP的双向通信协议，通过一次http握手建立持久链接，支持客户端和服务器之间的全双工通信。它的特点是低延迟，高效传输，和持久链接，适用于实时聊天和在线游戏等场景。相比http，websocket**减少了频繁请求和响应的开销**。

1.客户端通过http请求发起websocket链接，服务器响应确认，完成握手。

2.握手成功后，双方通过websocket协议交换数据。

