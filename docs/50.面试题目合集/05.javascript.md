---
title: JS面试问题合集
date: 2025-12-25 17:58:41
permalink: /qianduan/JS面试
categories:
  - 前端
  - javascript
tags:
  - javascript
---

<CollapsibleToc 
  title="快速导航" 
  :defaultOpen="true" 
  :minLevel="2" 
  :maxLevel="3" 
/>

## 1.let、const、var的区别?
**共同点**：都可以用来声明变量。
**区别**：
1.var具有变量提升机制，let和const没有。
2.var可以多次声明同一个变量，let、const不行。
3.var和let用来声明变量的，const是用来声明常量的。Var和let声明的变量可以再次赋值，const不可以。
4.var声明的变量没有自身作用域，let、const有

## 2.箭头函数与普通函数的区别？
1.箭头函数没有自己的this,this继承外层第一个非箭头函数的作用域。并且call()、apply()、bind()等方法不能改变箭头函数中this的指向。
::: details 示例
如这个例子继承外层fn()的this，指向obj
```js
const obj = {
  fn(){
    setTimeout(() => {
      console.log("箭头函数:", this.name); // 李四
    }, 0);
  }
}
```
:::

2.箭头函数不能作为构造函数使用
3.箭头函数没有prototype
4.箭头函数没有arguments

## 3.对原型、原型链的理解

**1.原型可以解决什么问题**：存放一些属性和方法，在js中实现继承。
**2.谁有原型**：函数拥有prototype，对象拥有__proto__。
**3.什么是原型？**
  - 构造函数的原型(`Person.prototype`),是一个对象，用于存储所有实例共享的方法 / 属性
  - 实例的原型`person.__proto__`,是实例的一个内部属性，指向其构造函数的 prototype 对象

**4.对象查找属性或者方法的顺序**。到构造函数中去查找->对象的原型->构造函数的原型中找->当前原型的原型中查找。
**5.原型链**：就是把原型串联起来，原型链的最顶端是null。

## 4.原型链的指向？
对象都有`__proto__`,指向它的原型对象，原型对象也是对象，也有`__proto__`，指向原型对象的原型对象，这样一层一层形成的链式结构就是原型链，最顶层找不到就会返回null

## 5.对promise的理解?
`Promise`是ES6提出的异步编程解决方案，用来解决回调地狱问题。Promise是一个构造函数，接收一个函数作为参数，返回一个promise实例。一个promise有三种状态分别是pending、resolved、rejected，分别代表了进行中，已成功和已失败。实例的状态只能由pending转变为resolved或者rejected状态，并且状态一经改变，就无法再被改变了。
我们可以通过then处理成功结果、catch 捕获失败/异常，finally执行无论成功失败都要做的逻辑，且then/catch支持链式调用。

### 5.1 promise的基本用法?
1.Promise的基本用法有创建promise对象(实例),通过 `new Promise((resolve, reject) => {})` 实例化。成功调用resolve传递结果(状态变为fulfilled),失败调用reject传递原因(状态变rejected)。
2.处理promise结果,`.then`处理成功结果，`.catch`处理失败结果
3.`.then`和`.catch`返回新的promise，可以链式调用。
4.处理多个promise(并行请求多个接口),`Promise.all()`等待所有promise完成;`Promise.race()`等待第一个完成的Promise,适合设置设置请求超时。
5.`.finally()`再Promise完成后无论成功或者失败都执行代码

### 5.2 对async/await的理解
async和await是JavaScript中用于简化异步代码的语法糖，基于promise，让代码的编写和阅读更接近于同步代码。Async函数的返回是一个promise对象。

## 6.对闭包的理解
- **1.闭包是什么？**
闭包是 JS 的一种特性，指内层函数可以访问外层函数作用域中的变量，即使外层函数已经执行完毕。创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。
**核心本质**是作用域链的延伸 —— 外层函数执行后，其执行上下文本应销毁，但因内层函数仍引用它的变量，导致该作用域被保留；
闭包的常用场景是**私有化变量、缓存数据**，但滥用会导致内存泄漏（未释放的作用域占用内存）。

- **2.闭包解决什么问题？**
闭包的优点：内部函数可以访问到外部函数的局部变量；

::: code-group
```js [基础闭包]
// 外层函数
function outer() {
  let num = 0; // 外层函数的变量
  // 内层函数：引用外层变量，且被返回（暴露到外部）
  return function inner() {
    num++;
    console.log(num); // 访问外层函数的num
  };
}

const fn = outer(); // 外层函数执行完毕，但其作用域被保留
fn(); // 输出1（闭包生效，num未被销毁）
fn(); // 输出2（num持续被引用）
```
```js [私有化变量]
function createCounter() {
  let count = 0; // 私有化变量，外部无法直接访问
  return {
    add: () => count++,
    get: () => count
  };
}

const counter = createCounter();
counter.add();
console.log(counter.get()); // 输出1
console.log(counter.count); // 输出undefined（变量私有化）
```
```js [内存泄漏解决]
function outer() {
  let largeData = new Array(1000000); // 大内存数据
  return function() {
    console.log(largeData.length);
  };
}

let fn = outer();
// 手动解除引用，释放内存（避免闭包导致内存泄漏）
fn = null;
```
:::

## 7.对作用域、作用域链的理解？
**1.作用域**：决定变量/函数的可访问范围，分为全局作用域、函数作用域、块级作用域
  - 全局作用域,所有未定义直接赋值的变量自动声明为全局作用域;所有window对象的属性拥有全局作用域
  - 函数作用域,函数作用域声明在函数内部的变量，一般只用固定的代码片段可以访问到。作用域是分层的，内层作用域可以访问到外层作用域，反之不行。
  - 块级作用域,使用let和const可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中创建（{}包裹的代码片段）

**2.作用域链**
当访问一个变量时，JS 会先在当前作用域查找，找不到就向上一级作用域查找，直到全局作用域，这条 “查找路径” 就是作用域链；它的本质是作用域的嵌套关系，也是闭包、this 指向的底层基础。

## 8.对执行上下文的理解
**执行上下文是javascript代码执行时的环境，它定义了变量、函数和代码的访问性**。每当JavaScript执行一段代码时，都会创建一个对应的执行上下文，它包含三个关键部分：**变量对象、作用域链和this的值**。执行上下文按照代码执行顺序被压入和弹出栈，全局上下文最先被创建，函数调用时创建新的上下文，执行完毕后销毁。简单来说，执行上下文就是JavaScript用来管理代码运行时的环境和规则。

## 9.对this对象的理解?
this时执行上下文中的一个属性，它指向最后一次调用这个方法的对象。
1.直接输出this指向全局对象。
2.this放在方法中，this指向调用这个方法的对象。
3.全局函数其实是window（全局对象）的方法，所以里面的this指向window。
4.事件中的this指向触发事件的dom。
5.如果一个函数用new调用，函数执行前会创建一个对象，this指向这个新创建的对象。
6.apply、call、bind可以显示的指定调用函数的this指向。

## 10.call()和apply()的区别
`call()`和`apply()`都能改变函数的this指向，核心区别是参数传递形式：

**1.call()**：第一个参数是 this 指向的对象，后续参数是逐个列出的参数列表；
**2.apply()**：第一个参数是 this 指向的对象，第二个参数是包含所有参数的数组或类数组对象；
**3.使用场景**：参数数量明确时用 call()，参数数量不确定或已存在于数组中时用 apply()

## 11.JavaScript为什么要进行变量提升它导致了什么问题

JavaScript 变量提升的**本质是编译阶段对声明的提前处理**:

1.JavaScript代码执行前会先创建执行上下文，在这个阶段，js引擎会扫描代码，将变量和函数的声明提升到作用域的顶部，变量提升是js早期设计的一部分，可能是为了简化语言实现或支持某些编程模式(递归调用)。
2.变量提升可能会导致作用域污染，var声明的变量是函数作用域，容易污染全局作用域或者外部作用域。

## 12.object.is()与比较操作符’===‘、’==‘的区别

三者的核心区别在于**比较的严格程度和特殊值处理**：

1.`==`（宽松相等）：先进行类型转换（强制类型转换），再比较值是否相等，可能出现 "1" == 1 为 true 的情况；
2.`===`（严格相等）：不进行类型转换，**仅当类型和值都相同时返回true**，但对 NaN 和 +0/-0 的处理存在特殊规则；
3.`Object.is()`：在严格相等的基础上优化了特殊值比较，解决了NaN不等于自身、+0 等于 -0 的问题，比较结果更符合直觉。

**如`NaN`的比较**
```js
console.log(NaN == NaN);          // false
console.log(NaN === NaN);         // false
console.log(Object.is(NaN, NaN)); // true
```
