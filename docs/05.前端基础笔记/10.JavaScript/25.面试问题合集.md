---
title: 面试问题合集
date: 2025-11-28 17:58:41
permalink: /qianduan/基础
categories:
  - 前端
  - javascript
tags:
  - javascript
---

<CollapsibleToc 
  title="快速导航" 
  :defaultOpen="true" 
  :minLevel="2" 
  :maxLevel="3" 
/>



## 问题1:JS有多少种继承方式(ES5)？
::: details 💡 继承的目标

- 属性私有化:子类实例的属性不共享
- 方法复用:父类的方法挂载到原型上，所有子类实例共享
- 传参灵活:子类能向父类构造函数传递参数；
- 原型链干净:子类原型修改不影响父类原型，无多余属性。

:::
**1.原型链继承** 📝
原型链继承(最基本继承)，把「子类的原型」直接指向「父类的实例」，让子类实例通过原型链访问父类的属性 / 方法。
- **缺点**:所有子类对象共享一个父类对象，也会共享父类实例的属性，子类新实例无法向父类构造函数传参。
```js
function Child() {
  this.name = 'Child';
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
```
**2.构造函数内继承** 📝
构造函数内继承(经典继承)，通过` Parent.call(this, 参数) `调用父类构造函数，把父类的实例属性「复制」到子类实例上。
- **缺点**:`Parent.call(this) `只复制了父类的实例属性，原型上的方法完全访问不到。`方法无法复用`
```js
function Child(name) {
  Parent.call(this, name);
}
```
**3.组合继承** 📝
组合继承（常用），原型链继承 + 构造函数继承。 
- 用「构造函数继承」解决「属性私有化 + 传参」问题；
- 用「原型链继承」解决「继承父类原型方法」问题。
- **唯一缺点**:父类构造函数被调用两次
```js
function Child(name) {
  Parent.call(this, name);
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
```

**4.原型式继承** 📝
本质是「原型链继承的简化版」,等价于`Object.create`。缺点也一样，除了每次定义一个子对象都要指定一个父对象。
```js
function newChild(parent) {
    function Child() {...}
    Child.prototype = parent
    Child.prototype.constructor = Child
    return new Child()
}
```
**5.寄生式继承** 📝
- **核心逻辑**:原型式继承 + 增强对象,在原型式继承的基础上，给新创建的子类对象「新增属性 / 方法」。
```js
function newChild(parent) {
    function Child() {...}
    Child.prototype = parent
    let child = new Child()
    child.say = function() {...}
    return child
}
```
**6.寄生组合式继承()** 📝
原型式->寄生式->寄生组合式是一个循序渐进的过程。 通过借用构造函数来继承属性, 在原型上添加共用的方法, 通过寄生式实现继承.
```js
function Child(name){
    Parent.call(this, name);
}
Child.prototype = Object.create(Parent.prototype); // 防止Child原型修改会影响到父原型
// Object.create()会造成的一个问题：Bar.prototype.constructor会改变，为什么会改变？
// 引用你不知道的JavaScript上中的一句话如果你创建了一个新对象并替换了函数默认的.prototype 对象引用，
// 那么新对象并不会自动获.constructor 属性。
Child.prototype.constructor = Child;
// constructor其实没有什么用处，只是JavaScript语言设计的历史遗留物。
// 由于constructor属性是可以变更的，所以未必真的指向对象的构造函数，只是一个提示。
// The constructor property does not cause any particular effects in your program
```
::: details 💡 ES6 Class extends 继承
ES6 新增的 class 和 extends 是「寄生组合式继承」的语法糖，底层逻辑和寄生组合式完全一致，但写法更接近传统面向对象。
:::
## 问题2:JS基于class实现继承(ES6)

## 3.什么是捕获与冒泡？
当一个DOM元素触发事件（比如点击按钮），事件会经历三个阶段:
**捕获阶段**：事件从最外层的祖先元素（window）向下传播到目标元素
**目标阶段**：事件到达触发事件的目标元素本身
**冒泡阶段**：事件从目标元素向上回传到最外层的祖先元素（window）

## 4.讲一讲js的this指针？
this表示当前上下文，this是在运行时确定的，而不是在定义时确定的

- 全局的this指针指向windows。在严格模式下，全局的this指针是undefined。
- 在函数中，this 表示全局对象。在严格模式下，this是undefined。
- 当一个方法被调用时，this被绑定到这个对象上。
- 如果一个函数当构造函数用，函数中的this会被绑定到这个新对象上。
- 事件的this指针指向元素本身。
- call/apply/bind，this指针会绑定指定的对象。
- 箭头函数中的this是指向箭头函数外的this，即箭头函数没有自己的this指针。


## 5.赋值/浅拷贝/深拷贝的区别？
- **赋值:** 只是将变量的「栈内存地址」复制给新变量，新旧变量指向同一个堆内存对象（引用类型）。基本赋值是直接复制值
- **浅拷贝**是拷贝一层，对象的内容仍是共用的，Object.assign()，拓展运算符都是浅拷贝。
```js
const obj1 = { name: '张三', info: { age: 18 } };
// 浅拷贝创建新对象
const obj2 = { ...obj1 }; 
//第一层是基础类型，直接赋值，不影响原对象
obj2.name = '李四';
console.log(obj1.name); 

// 2. 修改第二层引用类型（共享，影响原对象）
obj2.info.age = 20;
console.log(obj1.info.age); // 20（obj1被修改）
```
- **深拷贝**:创建全新的对象/数组，递归复制原对象的「所有层级属性」：**无论多少层嵌套的引用类型，都会创建新的堆内存，新旧对象完全独立，互不影响。**

- **应用场景：**
1.赋值：仅需复用对象，无需独立修改（如只读数据）；
2.浅拷贝：仅需修改对象第一层属性，深层属性共享（如简单表单数据、单层配置）；
3.深拷贝：需要完全独立的对象副本（如复杂表单编辑、状态管理（Vue/React）中避免原状态被篡改）。

- **区别总结：**
赋值：地址复用，改全影响；
浅拷贝：第一层独立，深层共享；
深拷贝：全层级独立，改互不影响。
