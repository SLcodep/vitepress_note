---
title: 手写题
date: 2025-11-27 17:24:35
permalink: /qian/write
# titleTag: 
categories:
  - 前端
tags:
  - 前端
---

这个文档主要是针对前端的面试手写题进行整理的，要求是自己要在vscode中手写运行一遍。针对promise这一部分因为内容较多，在Promise文档中进行单独整理



## 问题1:函数柯里化
::: details 💡 详情

**柯里化**是什么：将多参数函数转为分步接收单参数的函数链
**参数复用**：通过缓存部分参数，生成复用性更高的新函数，避免重复传入相同参数。

:::




## 问题2:LUR缓存
::: details 💡 LUR详情

LRU(Least Recently Used，最近最少使用)是一种缓存淘汰策略
**核心规则**是：当缓存空间达到上限时，优先淘汰最近最少被访问 / 使用的缓存项，保证缓存中保留的是「最常被使用」的数据，从而提升缓存命中率（高频数据大概率被再次访问）。
运用：浏览器缓存策略、keep-alive

:::

## 问题3:深拷贝
## 问题4:手写bind、call、apply
## 问题5:节流
## 问题6:防抖
## 问题7:instanceof实现
## 问题8:JS有多少种继承方式？
::: details 💡 继承的目标

- 属性私有化:子类实例的属性不共享
- 方法复用:父类的方法挂载到原型上，所有子类实例共享
- 传参灵活:子类能向父类构造函数传递参数；
- 原型链干净:子类原型修改不影响父类原型，无多余属性。

:::
**原型链继承** 📝
原型链继承(最基本继承)，把「子类的原型」直接指向「父类的实例」，让子类实例通过原型链访问父类的属性 / 方法。
- **缺点**:所有子类对象共享一个父类对象，也会共享父类实例的属性，子类新实例无法向父类构造函数传参。
```js
function Child() {
  this.name = 'Child';
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
```
**构造函数内继承** 📝
构造函数内继承(经典继承)，通过` Parent.call(this, 参数) `调用父类构造函数，把父类的实例属性「复制」到子类实例上。
- **缺点**:`Parent.call(this) `只复制了父类的实例属性，原型上的方法完全访问不到。`方法无法复用`
```js
function Child(name) {
  Parent.call(this, name);
}
```
**组合继承** 📝
组合继承（常用），原型链继承 + 构造函数继承。 
- 用「构造函数继承」解决「属性私有化 + 传参」问题；
- 用「原型链继承」解决「继承父类原型方法」问题。
- **唯一缺点**:父类构造函数被调用两次
```js
function Child(name) {
  Parent.call(this, name);
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
```

**原型式继承** 📝
本质是「原型链继承的简化版」,等价于`Object.create`。缺点也一样，除了每次定义一个子对象都要指定一个父对象。
```js
function newChild(parent) {
    function Child() {...}
    Child.prototype = parent
    Child.prototype.constructor = Child
    return new Child()
}
```
**寄生式继承** 📝
- **核心逻辑**:原型式继承 + 增强对象,在原型式继承的基础上，给新创建的子类对象「新增属性 / 方法」。
```js
function newChild(parent) {
    function Child() {...}
    Child.prototype = parent
    let child = new Child()
    child.say = function() {...}
    return child
}
```
**寄生组合式继承** 📝
原型式->寄生式->寄生组合式是一个循序渐进的过程。 通过借用构造函数来继承属性, 在原型上添加共用的方法, 通过寄生式实现继承.
```js
function Child(name){
    Parent.call(this, name);
}
Child.prototype = Object.create(Parent.prototype); // 防止Child原型修改会影响到父原型
// Object.create()会造成的一个问题：Bar.prototype.constructor会改变，为什么会改变？
// 引用你不知道的JavaScript上中的一句话如果你创建了一个新对象并替换了函数默认的.prototype 对象引用，
// 那么新对象并不会自动获.constructor 属性。
Child.prototype.constructor = Child;
// constructor其实没有什么用处，只是JavaScript语言设计的历史遗留物。
// 由于constructor属性是可以变更的，所以未必真的指向对象的构造函数，只是一个提示。
// The constructor property does not cause any particular effects in your program
```
::: details 💡 ES6 Class extends 继承
ES6 新增的 class 和 extends 是「寄生组合式继承」的语法糖，底层逻辑和寄生组合式完全一致，但写法更接近传统面向对象。
```js

```
:::
## 问题9:订阅模式
## 问题6:防抖


