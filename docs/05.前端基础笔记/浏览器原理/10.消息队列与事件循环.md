---
title: 消息队列与事件循环
date: 2025-11-27 17:24:35
permalink: /browser/03
# titleTag: 
categories:
  - 前端
tags:
  - 前端
---



## 消息队列与事件循环

在介绍消息队列之前，先补充一下浏览器的渲染过程，要经过很多操作，这就涉及一个问题，如何有条不紊地执行不同类型的任务？所以就有统筹调度系统----消息队列和事件循环系统。

> 消息队列是**异步任务调度**的核心，解决同步、异步操作的调度分配，分为宏任务、微任务。
>
> 事件循环是让单线程JS有序地动起来，按照一次次循环同步、微任务、渲染、宏任务

![76429691826](../../public/qian/1764296918267.png)

### 事件循环(**Event Loop**)

事件循环中的核心是微任务和宏任务，两者负责异步任务，防止在JS线程中因为等待造成的阻塞。

```javascript
    console.log('task1')

    setTimeout(()=>{
      new Promise((resolve,reject)=>{
        console.log('task2')
        resolve()
      }).then(()=>{
        console.log('task4')
      }).then(()=>{
        console.log('task7')
      })
    },0)

    new Promise((resolve,reject)=>{
      console.log('task3')
      resolve()
    }).then(()=>{
      console.log('task6')
    })

    console.log('task5')
```

在这里我们能够看到，代码块从上到下按照执行上下文进行，首先是执行同步任务，然后将异步任务交给其他线程进行出来，在同步任务执行完成之后，先清理微任务队列；之后再对宏任务进行出来，

![76429720191](../../public/qian/1764297201915.png)





## 异步编程

> 同步回调和异步回调的最大区别在于**同步回调函数是在执行函数内部被执行的，而异步回调函数是在执行函数外部被执行的。**Promise和async的作用是解决回调地狱的问题，目的是能不能像编写同步代码那样，书写异步代码。

案例是，我想获得服务器返回的订单详情，我需要进行哪些操作？

1. 先请求用户基本信息（需要用户 ID）；
2. 拿到用户 ID 后，请求该用户的订单列表；
3. 拿到订单列表后，请求第一个订单的详情；
4. 拿到订单详情后，更新页面 DOM；
5. 每一步都要处理请求失败的情况。

使用原始Ajax时，

```javascript
// 模拟原生Ajax请求函数（简化版）
function request(url, successCallback, errorCallback) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.onload = function() {
    if (xhr.status === 200) {
      successCallback(JSON.parse(xhr.responseText));
    } else {
      errorCallback(new Error(`请求失败：${xhr.status}`));
    }
  };
  xhr.onerror = function() {
    errorCallback(new Error('网络异常'));
  };
  xhr.send();
}

// 回调地狱核心代码
// 第一步：请求用户基本信息
request('/api/user/1', function(user) {
  console.log('获取用户信息：', user);
  
  // 第二步：依赖用户ID，请求订单列表
  request(`/api/orders?userId=${user.id}`, function(orders) {
    console.log('获取订单列表：', orders);
    if (orders.length === 0) {
      alert('暂无订单');
      return;
    }
    const firstOrderId = orders[0].id;
    
    // 第三步：依赖订单ID，请求订单详情
    request(`/api/order/detail?orderId=${firstOrderId}`, function(orderDetail) {
      console.log('获取订单详情：', orderDetail);
      
      // 第四步：依赖订单详情，更新DOM
      successCallback(function() {
        document.querySelector('.order-title').innerText = orderDetail.title;
        document.querySelector('.order-price').innerText = orderDetail.price;
        document.querySelector('.order-time').innerText = orderDetail.createTime;
        
        // 甚至可能继续嵌套：请求订单对应的商品信息
        request(`/api/goods?goodsId=${orderDetail.goodsId}`, function(goods) {
          document.querySelector('.goods-name').innerText = goods.name;
        }, function(err) {
          // 第四层错误处理
          console.error('请求商品信息失败：', err);
        });
      }, function(err) {
        // 第三层错误处理
        console.error('更新DOM失败：', err);
      });
    }, function(err) {
      // 第二层错误处理
      console.error('请求订单详情失败：', err);
    });
  }, function(err) {
    // 第一层错误处理
    console.error('请求订单列表失败：', err);
  });
}, function(err) {
  // 最外层错误处理
  console.error('请求用户信息失败：', err);
});
```



### Promise是如何解决的？

promise有三种状态执行中、成功、失败。通过成功、失败来控制执行的链路，不用像上面显示地使用回调函数或者嵌入包裹。

```js
fetch(id_url)
.then((response) => {
return response.text()
})
.then((response) => {
let new_name_url = name_url + "?id=" + response
return fetch(new_name_url)
}).then((response) => {
return response.text()
}).then((response) => {
console.log(response)//输出最终的结果
})  

```



### Generator函数实现更加线性化逻辑

> 虽然使用Promise可以解决回调地狱中编码不线性的问题，但这种方式充满了Promise的then()方法，如果处理流程比较复杂的话，那么整段代码将充斥着大量的then，异步逻辑之间依然被then方法打断了，因此这种方式的语义化不明显，代码不能很好地表示执行流程。





### async/await

> 由于生成器函数可以暂停，因此我们可以在生成器内部编写完整的异步逻辑代码，不过生成器依然需要使用**额外的co函数来驱动生成器函数的执行**，这一点非常不友好。

**ES7 引入了async/await，这是JavaScript异步编程的一个重大改进，它改进了生成器的缺点，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力**。











