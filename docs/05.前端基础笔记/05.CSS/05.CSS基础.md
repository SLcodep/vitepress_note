---
title: CSS基础
date: 2024-12-25 00:58:41
permalink: /qianduan/css
categories:
  - 前端
  - css
tags:
  - css
---

## 1.css选择器的分类有哪些？

## 2.Flexbox布局
::: details 💡 Flexbox布局的核心概念

- **一个问题**：如何完美居中？
- **两大轴线**：主轴与交叉轴
- **三大核心**：`flex-direction`决定主轴的方向;`justify-content`定义容器成员在主轴上的对齐方式;`align-items`定义容器成员在交叉轴上的对齐方式。
``
:::




### 2.1 水平垂直居中的实现方式

::: code-group
```js [绝对定位]
.parent {
    position: relative; //相对定位，偏离原先文档位置
}
 
.child {
    position: absolute; //绝对定位，找最近的position不为 static 的祖先容器
    left: 50%; 
    top: 50%;
    transform: translate(-50%,-50%); //让子元素以自身为基准，向左、向上各偏移自身宽/高的 50%
}
```

```js [flux布局]
.parent {
    display: flex;  //布局方式,默认主轴方向是水平方向
    //flux-direction:column是将主轴方向设置为垂直方向
    justify-content:center; //主轴的对齐方式
    align-items:center; //交叉轴的对齐方式
}
```

:::
------

### 2.2 深度理解Flexbox
:::details 💡 深度理解Flexbox
- **理解核心:** `flex-grow`（剩余空间分配比例）、`flex-shrink`（空间不足时的收缩比例）、`flex-basis`（项目的基准尺寸）三个属性。
- **学习空间分布的"三步法"决策逻辑**

:::

首先要理解的是flex渲染过程是如何分配空间大小的?
![image](/qian/flex样式计算.png)
如果一个div盒子里面装着3个小盒子，首先要计算小盒子的基础空间大小，div盒子的大小和内部的小盒子的基础空间大小之和进行对比来决定是收缩还是拉伸。
- **拉伸**
  默认进行平均分配，如大盒子600px，三个小盒子分别是100，100，100。计算得到的会是有200多余部分，就会平均到3个小盒子上最终得到的是200，200，200的宽度。
- **压缩**
  压缩和拉伸是同理的，默认都是平均分配。

------

### 问题1:Flex:1 到底意味着什么？
上面提到的三个属性，`flex-basis`基础尺寸,`flex-grow`是拉伸比例,`flex-shrink`是压缩比例。
**flex属性：** flex-grow，flex-shrink和flex-basis，默认值为0 1 auto。**flex:1 表示 flex: 1 1** **0%**

- 第一个参数表示: **flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大；**
- 第二个参数表示: **flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小；**
- 第三个参数表示: **flex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小(文字大小，图片宽度)。**

::: code-group

```js [单独使用]
//效果是占满容器剩余空间，下面能够盒子宽度为60-100=500px
<div class="container" style="display: flex; width: 600px;">
  <div class="fixed" style="width: 100px;">固定宽度</div>
  <div class="flex-item" style="flex: 1;">flex:1 子项</div>
</div>
```

```js [多个flex:1子项]
//均匀分配,1:1:1
<div class="container" style="display: flex; width: 600px;">
  <div class="item1" style="flex: 1;">flex:1</div>
  <div class="item2" style="flex: 1;">flex:1</div>
  <div class="item3" style="flex: 1;">flex:1</div>
</div>
```

```js [混合flex:1和flex:2]
//按比例分配
<div class="container" style="display: flex; width: 600px;">
  <div class="item1" style="flex: 1;">flex:1</div>
  <div class="item2" style="flex: 2;">flex:2</div>
</div>
```

:::

**面试回答**

- flex: 1表示 flex: 1 1 0%效果是让 Flex 项目成为「完全弹性的自适应元素」——**无视自身固有尺寸，按比例均分容器剩余空间，且空间不足时自动收缩**。

- 默认的0 1 auto的效果是按照子盒子的**内容进行分配尺度，没有拉伸，压缩按照等比例**。

------

### 问题2：三栏布局的实现

首先明确两栏布局或者三栏布局的要求。

| 布局类型 | 结构特征                                       | 面试高频变体                                                                                    |
| -------- | ---------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| 两栏布局 | 页面分为左右两列（或上下两列，面试多考察左右） | ① 左侧固定宽度 + 右侧自适应；② 右侧固定 + 左侧自适应；③ 两侧自适应 + 中间固定（本质是三栏简化） |
| 三栏布局 | 页面分为左、中、右三列                         | ① 左右固定宽度 + 中间自适应（最常考）；② 左固定 + 中右自适应；③ 全自适应（按比例分配）          |

**实现原理**：利用上面提到的flex的属性，**单独flex:1来分配剩余的空间。** 配合`max-width`防止窗口变化时过度拉伸或者压缩。



**两栏布局的实现**：左侧固定右侧自适应

```js
<div class="layout">
  <div class="sidebar">左侧固定栏（宽度200px）</div>
  <div class="main">右侧自适应栏（占剩余宽度）</div>
</div>

<style>
.layout {
  display: flex;
  height: 100vh; /* 可选，撑满视口高度 */
}
.sidebar {
  width: 200px; /* 固定宽度 */
  flex-shrink: 0; /* 禁止收缩（避免空间不足时被压缩） */
}
.main {
  flex: 1; /* 占剩余所有宽度（等价于 flex:1 1 0%） */
  overflow: auto; /* 内容溢出时纵向滚动 */
}      
</style>
```

**三栏布局的实现**：左右固定 + 中间自适应

```js
<div class="layout">
  <div class="left">左栏（固定200px）</div>
  <div class="main">中栏（自适应）</div>
  <div class="right">右栏（固定150px）</div>
</div>
.layout {
  display: flex;
  height: 100vh;
}
.left {
  width: 200px;
  flex-shrink: 0; /* 禁止收缩 */
}
.main {
  flex: 1; /* 占剩余所有宽度 */
  overflow: auto;
}
.right {
  width: 150px;
  flex-shrink: 0; /* 禁止收缩 */
}
```
## 3.px、em、rem的区别及使用场景?
三者的区别：
- px是固定的像素，一旦设置了就无法因为适应页面大小而改变。
- em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。
- em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。

使用场景：
对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。

## 4.为什么需要清除浮动？清除浮动的方式
> **浮动的定义**：容器不设置高度且子元素浮动时，容器高度不能被内容撑开。内容会溢出到容器外而影响布局。这种现象被称为浮动（溢出）。
清除浮动是为了解决**父元素高度塌陷**问题：
**1.原因**：浮动元素脱离文档流，父元素无法感知其高度，导致高度为0，影响后续布局
**2.常用方式：**
  - 父元素设置`overflow: hidden`（触发 BFC，简单高效）
  - 使用`clearfix`伪元素（推荐，兼容性好）
  - 父元素设置 `display: flow-root`

:::details 原理
```js
<style>
  .parent { border: 2px solid #000; }
  .child { width: 100px; height: 100px; background: red; float: left; }
</style>
<div class="parent">
  <div class="child"></div>
</div>
<p>后续元素会错位</p>
```

**1.父元素设置`overflow:hidden`**
原理：触发 BFC，包含浮动元素。
```js
.parent { overflow: hidden; }
```

**2.clearfix伪元素法**
```js
<div class="parent clearfix">
  <div class="child"></div>
</div>

.clearfix::after {
  content: "";
  display: block;
  clear: both;
}
```
**3.父元素设置 display:flow-root**
原理：触发 BFC，现代浏览器原生支持。
```js
.parent { display: flow-root; }
```
:::

## 5.对BFC的理解，如何创建BFC?
> 块格式化上下文BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。

**1.特性**：内部元素垂直排列、外边距不重叠、包含浮动元素、不会与浮动元素重叠；
**2.作用**：解决高度塌陷、清除浮动、防止外边距重叠、实现自适应两栏布局；

| 创建方法                | 示例                     | 适用场景                   |
| ----------------------- | ------------------------ | -------------------------- |
| 根元素                  | `<html>`                 | 页面根 BFC                 |
| 浮动元素                | `float: left;`           | 需浮动且包含内部元素       |
| 绝对定位元素            | `position: absolute;`    | 需脱离文档流且包含内部元素 |
| 行内块元素              | `display: inline-block;` | 需行内块布局且包含内部元素 |
| 表格单元格              | `display: table-cell;`   | 需表格布局且包含内部元素   |
| 弹性元素                | `display: flex;`         | 需弹性布局且包含内部元素   |
| 网格元素                | `display: grid;`         | 需网格布局且包含内部元素   |
| `overflow`不为`visible` | `overflow: hidden;`      | 简单高效，适合大多数场景   |
